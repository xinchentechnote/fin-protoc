package parser

import (
	"fmt"
	"strings"
	"time"

	"github.com/iancoleman/strcase"
	"github.com/xinchentechnote/fin-protoc/internal/model"
)

// CppType represents a C++ type with its name, basic type, and size.
type CppType struct {
	Name      string
	BasicType string
	Le        string
	Size      int
	TestValue string
}

var cppBasicTypeMap = map[string]CppType{
	"i8":  {"int8_t", "int", "i8", 1, "1"},
	"i16": {"int16_t", "int", "i16_le", 2, "2"},
	"i32": {"int32_t", "int", "i32_le", 4, "4"},
	"i64": {"int64_t", "int", "i64_le", 8, "8"},
	"u8":  {"uint8_t", "unsigned int", "u8", 1, "1"},
	"u16": {"uint16_t", "unsigned int", "u16_le", 2, "2"},
	"u32": {"uint32_t", "unsigned int", "u32_le", 4, "4"},
	"u64": {"uint64_t", "unsigned int", "u64_le", 8, "8"},
	"f32": {"float", "float", "f32_le", 4, "4"},
	"f64": {"double", "double", "f64_le", 8, "8"},
}

// CppGenerator a go code generator
type CppGenerator struct {
	config   *GeneratorConfig
	binModel *model.BinaryModel
	hasGen   map[string]*model.Packet
}

// NewCppGenerator new
func NewCppGenerator(config *GeneratorConfig, binModel *model.BinaryModel) *CppGenerator {
	return &CppGenerator{
		config:   config,
		binModel: binModel,
		hasGen:   make(map[string]*model.Packet),
	}
}

// Generate go code
func (g CppGenerator) Generate(binModel *model.BinaryModel) (map[string][]byte, error) {
	output := make(map[string][]byte)

	rootPacketName := strcase.ToSnake(binModel.RootPacket.Name)
	output["include/"+rootPacketName+".hpp"] = []byte(g.generateHppFile(binModel))
	output["test/"+rootPacketName+"_test.cpp"] = []byte(g.generateTestFile(binModel))
	return output, nil
}

func (g CppGenerator) generateHppFile(binModel *model.BinaryModel) string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("// Copyright %d xinchentechnote\n", time.Now().Year()))
	b.WriteString("// Code generated by fin-protoc. DO NOT EDIT.\n")
	b.WriteString("#pragma once\n")
	b.WriteString("#include <cstdint>\n")
	b.WriteString("#include <functional>\n")
	b.WriteString("#include <iomanip>\n")
	b.WriteString("#include <memory>\n")
	b.WriteString("#include <string>\n")
	b.WriteString("#include <unordered_map>\n")
	b.WriteString("#include <vector>\n")
	b.WriteString("#include <iostream>\n")
	b.WriteString("#include \"include/codec.hpp\"\n")
	b.WriteString("#include \"include/bytebuf.hpp\"\n")
	b.WriteString("#include \"include/checksum.hpp\"\n")
	b.WriteString("#include \"message_factory.hpp\"\n")
	b.WriteString("\n")
	for _, pkt := range binModel.Packets {
		if !pkt.IsRoot {
			code := g.generateCodeForPacket(pkt)
			b.WriteString(code)
			b.WriteString("\n")
		}
	}
	code := g.generateCodeForPacket(binModel.RootPacket)
	b.WriteString(code)
	b.WriteString("\n")
	return b.String()
}

func (g CppGenerator) generateCodeForPacket(p *model.Packet) string {
	if _, ok := g.hasGen[p.Name]; ok {
		return ""
	}
	g.hasGen[p.Name] = p
	var b strings.Builder

	//iner
	for _, f := range p.Fields {
		if f.InerObject != nil {
			b.WriteString(g.generateCodeForPacket(f.InerObject))
			b.WriteString("\n")
		}
		if mp, ok := g.binModel.PacketsMap[f.GetType()]; ok {
			b.WriteString(g.generateCodeForPacket(mp))
			b.WriteString("\n")
		}
		if f.GetType() == "match" {
			for _, pair := range f.MatchPairs {
				mp := g.binModel.PacketsMap[pair.Value]
				packetCode := g.generateCodeForPacket(mp)
				if packetCode != "" {
					b.WriteString(packetCode)
					b.WriteString("\n")
				}
			}
		}
	}
	//factory
	for key, pairs := range p.MatchFields {
		f := p.FieldMap[key]
		b.WriteString(fmt.Sprintf("struct %sTag{};\n", strcase.ToCamel(p.Name)))
		b.WriteString(fmt.Sprintf("using %sMessageFactory = MessageFactory<%s, codec::BinaryCodec, %sTag>;\n", strcase.ToCamel(p.Name), g.getFieldType(f), strcase.ToCamel(p.Name)))
		for _, pair := range pairs {
			b.WriteString(fmt.Sprintf("REGISTER_MESSAGE(%sMessageFactory, %s, %s);\n", strcase.ToCamel(p.Name), pair.Key, pair.Value))
		}
		b.WriteString("\n")
		b.WriteString("\n")
	}

	//struct
	b.WriteString(fmt.Sprintf("struct %s : public codec::BinaryCodec {\n", p.Name))
	for _, field := range p.Fields {
		b.WriteString("    " + g.getFieldType(field) + " " + strcase.ToLowerCamel(field.Name) + ";\n")
	}

	b.WriteString("\n")
	//gen encode method
	b.WriteString(AddIndent4ln(g.generateEncode(p)))
	b.WriteString("\n")

	//gen decode method
	b.WriteString(AddIndent4ln(g.generateDecode(p)))
	b.WriteString("\n")

	//gen equals method
	b.WriteString(AddIndent4ln(g.generateEquals(p)))

	//tostring
	b.WriteString(AddIndent4ln(g.generateToString(p)))

	b.WriteString("};\n")

	// override operator<<
	b.WriteString("\n")
	b.WriteString(g.generateOstreamOperator(p))

	b.WriteString("\n")
	return b.String()
}

func (g CppGenerator) generateEquals(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("bool equals(const BinaryCodec& other) const override {\n")
	b.WriteString(fmt.Sprintf("    const auto* checkType = dynamic_cast<const %s*>(&other);\n", strcase.ToCamel(p.Name)))
	b.WriteString("    if(!checkType) return false;\n")
	b.WriteString("    return ")

	if len(p.Fields) == 0 {
		b.WriteString("true;\n")
	} else {
		for idx, f := range p.Fields {
			if idx > 0 {
				b.WriteString("           && ")
			}
			fieldNameLowerCamel := strcase.ToLowerCamel(f.Name)
			if f.GetType() == "match" {
				b.WriteString(fmt.Sprintf("%s->equals(*checkType->%s)", fieldNameLowerCamel, fieldNameLowerCamel))
			} else {
				b.WriteString(fmt.Sprintf("%s == checkType->%s", fieldNameLowerCamel, fieldNameLowerCamel))
			}
			if idx == len(p.Fields)-1 {
				b.WriteString(";\n")
			} else {
				b.WriteString("\n")
			}
		}
	}
	b.WriteString("}\n")
	return b.String()
}

// GetPadding field.Padding or config.Padding
func (g CppGenerator) GetPadding(f *model.Field) *model.Padding {
	if f.Padding != nil {
		return f.Padding
	}
	return g.config.Padding
}

func (g CppGenerator) generateEncode(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("void encode(ByteBuf& buf) const override {\n")
	strLenTyp := cppBasicTypeMap[g.config.StringLenPrefixLenType]
	listLenTyp := cppBasicTypeMap[g.config.ListLenPrefixLenType]
	for _, f := range p.Fields {
		fieldNameLowerCamel := strcase.ToLowerCamel(f.Name)
		padding := g.GetPadding(f)
		if f.LengthOfField != "" {
			typ := cppBasicTypeMap[f.GetType()]
			b.WriteString(fmt.Sprintf("    auto %sPos = buf.writer_index();\n", fieldNameLowerCamel))
			if g.config.LittleEndian {
				b.WriteString(fmt.Sprintf("    buf.write_%s(0);\n", typ.Le))
			} else {
				b.WriteString(fmt.Sprintf("    buf.write_%s(0);\n", f.GetType()))
			}
		} else if f.CheckSumType != "" {
			typ := cppBasicTypeMap[f.GetType()]
			ty := f.GetType()
			if g.config.LittleEndian {
				ty = typ.Le
			}
			b.WriteString(fmt.Sprintf("    auto service = ChecksumServiceContext::instance().get<ByteBuf, %s>(%s);\n", typ.Name, f.CheckSumType))
			b.WriteString("    if(service != nullptr){\n")
			b.WriteString("        auto cs = service->calc(buf);\n")
			b.WriteString(fmt.Sprintf("        buf.write_%s(cs);\n", ty))
			b.WriteString("    } else {\n")
			b.WriteString(fmt.Sprintf("        buf.write_%s(%s);\n", ty, fieldNameLowerCamel))
			b.WriteString("    }\n")
		} else if p.LengthField != nil && f.Name == p.LengthField.LengthOfField {
			b.WriteString(fmt.Sprintf("    auto %sStart = buf.writer_index();\n", fieldNameLowerCamel))
			b.WriteString(fmt.Sprintf("    %s->encode(buf);\n", fieldNameLowerCamel))
			b.WriteString(fmt.Sprintf("    auto %sEnd = buf.writer_index();\n", fieldNameLowerCamel))
			typ := cppBasicTypeMap[p.LengthField.GetType()]
			bodyName := strcase.ToLowerCamel(p.LengthField.LengthOfField)
			lengthFieldName := strcase.ToLowerCamel(p.LengthField.Name)
			b.WriteString(fmt.Sprintf("    auto %sLen_ = static_cast<%s>(%sEnd - %sStart);\n", bodyName, typ.BasicType, fieldNameLowerCamel, fieldNameLowerCamel))
			if g.config.LittleEndian {
				b.WriteString(fmt.Sprintf("    buf.write_%s_at(%sPos, %sLen_);\n", typ.Le, lengthFieldName, bodyName))
			} else {
				b.WriteString(fmt.Sprintf("    buf.write_%s_at(%sPos, %sLen_);\n", p.LengthField.GetType(), lengthFieldName, bodyName))
			}
		} else if typ, ok := cppBasicTypeMap[f.GetType()]; ok {
			if f.IsRepeat {
				if g.config.LittleEndian {
					b.WriteString(fmt.Sprintf("    codec::write_basic_type_le<%s,%s>(buf,%s);\n", listLenTyp.Name, typ.Name, fieldNameLowerCamel))
				} else {
					b.WriteString(fmt.Sprintf("    codec::write_basic_type<%s,%s>(buf,%s);\n", listLenTyp.Name, typ.Name, fieldNameLowerCamel))
				}
			} else {
				if g.config.LittleEndian {
					b.WriteString(fmt.Sprintf("    buf.write_%s(%s);\n", typ.Le, fieldNameLowerCamel))
				} else {
					b.WriteString(fmt.Sprintf("    buf.write_%s(%s);\n", f.GetType(), fieldNameLowerCamel))
				}
			}
		} else if size, ok := model.ParseCharArrayType(f.GetType()); ok {
			if padding != nil {
				if f.IsRepeat {
					if g.config.LittleEndian {
						b.WriteString(fmt.Sprintf("    codec::write_fixed_string_list_le<%s>(buf, %s, %d, %s, %t);\n", listLenTyp.Name, fieldNameLowerCamel, size, padding.PadChar, padding.PadLeft))
					} else {
						b.WriteString(fmt.Sprintf("    codec::write_fixed_string_list<%s>(buf, %s, %d, %s, %t);\n", listLenTyp.Name, fieldNameLowerCamel, size, padding.PadChar, padding.PadLeft))
					}
				} else {
					b.WriteString(fmt.Sprintf("    codec::write_fixed_string(buf, %s, %d, %s, %t);\n", fieldNameLowerCamel, size, padding.PadChar, padding.PadLeft))
				}
			} else {
				if f.IsRepeat {
					if g.config.LittleEndian {
						b.WriteString(fmt.Sprintf("    codec::write_fixed_string_list_le<%s>(buf, %s, %d);\n", listLenTyp.Name, fieldNameLowerCamel, size))
					} else {
						b.WriteString(fmt.Sprintf("    codec::write_fixed_string_list<%s>(buf, %s, %d);\n", listLenTyp.Name, fieldNameLowerCamel, size))
					}
				} else {
					b.WriteString(fmt.Sprintf("    codec::write_fixed_string(buf, %s, %d);\n", fieldNameLowerCamel, size))
				}
			}

		} else if f.GetType() == "string" || f.GetType() == "char[]" {
			if f.IsRepeat {
				if g.config.LittleEndian {
					b.WriteString(fmt.Sprintf("    codec::write_string_list_le<%s,%s>(buf, %s);\n", listLenTyp.Name, strLenTyp.Name, fieldNameLowerCamel))
				} else {
					b.WriteString(fmt.Sprintf("    codec::write_string_list<%s,%s>(buf, %s);\n", listLenTyp.Name, strLenTyp.Name, fieldNameLowerCamel))
				}
			} else {
				if g.config.LittleEndian {
					b.WriteString(fmt.Sprintf("    codec::write_string_le<%s>(buf, %s);\n", strLenTyp.Name, fieldNameLowerCamel))
				} else {
					b.WriteString(fmt.Sprintf("    codec::write_string<%s>(buf, %s);\n", strLenTyp.Name, fieldNameLowerCamel))
				}
			}
		} else if f.InerObject != nil {
			if f.IsRepeat {
				if g.config.LittleEndian {
					b.WriteString(fmt.Sprintf("    codec::write_object_List_le<%s>(buf,%s);\n", listLenTyp.Name, fieldNameLowerCamel))
				} else {
					b.WriteString(fmt.Sprintf("    codec::write_object_List<%s>(buf,%s);\n", listLenTyp.Name, fieldNameLowerCamel))
				}
			} else {
				b.WriteString(fmt.Sprintf("    %s.encode(buf);\n", fieldNameLowerCamel))
			}
		} else if _, ok := g.binModel.PacketsMap[f.GetType()]; ok {
			if f.IsRepeat {
				if g.config.LittleEndian {
					b.WriteString(fmt.Sprintf("    codec::write_object_List_le<%s>(buf,%s);\n", listLenTyp.Name, fieldNameLowerCamel))
				} else {
					b.WriteString(fmt.Sprintf("    codec::write_object_List<%s>(buf,%s);\n", listLenTyp.Name, fieldNameLowerCamel))
				}
			} else {
				b.WriteString(fmt.Sprintf("    %s.encode(buf);\n", fieldNameLowerCamel))
			}
		} else if f.GetType() == "match" {
			b.WriteString(fmt.Sprintf("    %s->encode(buf);\n", fieldNameLowerCamel))
		} else {
			b.WriteString("-- unsupport type:" + f.GetType() + "\n")
		}
	}
	b.WriteString("}\n")
	return b.String()
}

func (g CppGenerator) generateDecode(p *model.Packet) string {
	var b strings.Builder
	strLenTyp := cppBasicTypeMap[g.config.StringLenPrefixLenType]
	listLenTyp := cppBasicTypeMap[g.config.ListLenPrefixLenType]
	b.WriteString("void decode(ByteBuf& buf) override {\n")
	for _, f := range p.Fields {
		fieldNameLowerCamel := strcase.ToLowerCamel(f.Name)
		padding := g.GetPadding(f)
		if typ, ok := cppBasicTypeMap[f.GetType()]; ok {
			if f.IsRepeat {
				if g.config.LittleEndian {
					b.WriteString(fmt.Sprintf("    %s = codec::read_basic_type_le<%s,%s>(buf);\n", fieldNameLowerCamel, listLenTyp.Name, typ.Name))
				} else {
					b.WriteString(fmt.Sprintf("    %s = codec::read_basic_type<%s,%s>(buf);\n", fieldNameLowerCamel, listLenTyp.Name, typ.Name))
				}

			} else {
				if g.config.LittleEndian {
					b.WriteString(fmt.Sprintf("    %s = buf.read_%s();\n", fieldNameLowerCamel, typ.Le))
				} else {
					b.WriteString(fmt.Sprintf("    %s = buf.read_%s();\n", fieldNameLowerCamel, f.GetType()))
				}
			}

		} else if size, ok := model.ParseCharArrayType(f.GetType()); ok {
			if padding != nil {
				if f.IsRepeat {
					if g.config.LittleEndian {
						b.WriteString(fmt.Sprintf("    %s = codec::read_fixed_string_list_le<%s>(buf, %d, %s, %t);\n", fieldNameLowerCamel, listLenTyp.Name, size, padding.PadChar, padding.PadLeft))
					} else {
						b.WriteString(fmt.Sprintf("    %s = codec::read_fixed_string_list<%s>(buf, %d, %s, %t);\n", fieldNameLowerCamel, listLenTyp.Name, size, padding.PadChar, padding.PadLeft))
					}
				} else {
					b.WriteString(fmt.Sprintf("    %s = codec::read_fixed_string(buf, %d, %s, %t);\n", fieldNameLowerCamel, size, padding.PadChar, padding.PadLeft))
				}
			} else {
				if f.IsRepeat {
					if g.config.LittleEndian {
						b.WriteString(fmt.Sprintf("    %s = codec::read_fixed_string_list_le<%s>(buf, %d);\n", fieldNameLowerCamel, listLenTyp.Name, size))
					} else {
						b.WriteString(fmt.Sprintf("    %s = codec::read_fixed_string_list<%s>(buf, %d);\n", fieldNameLowerCamel, listLenTyp.Name, size))
					}
				} else {
					b.WriteString(fmt.Sprintf("    %s = codec::read_fixed_string(buf, %d);\n", fieldNameLowerCamel, size))
				}
			}

		} else if f.GetType() == "string" || f.GetType() == "char[]" {
			if f.IsRepeat {
				if g.config.LittleEndian {
					b.WriteString(fmt.Sprintf("    %s = codec::read_string_list_le<%s,%s>(buf);\n", fieldNameLowerCamel, listLenTyp.Name, strLenTyp.Name))
				} else {
					b.WriteString(fmt.Sprintf("    %s = codec::read_string_list<%s,%s>(buf);\n", fieldNameLowerCamel, listLenTyp.Name, strLenTyp.Name))
				}
			} else {
				if g.config.LittleEndian {
					b.WriteString(fmt.Sprintf("    %s = codec::read_string_le<%s>(buf);\n", fieldNameLowerCamel, strLenTyp.Name))
				} else {
					b.WriteString(fmt.Sprintf("    %s = codec::read_string<%s>(buf);\n", fieldNameLowerCamel, strLenTyp.Name))
				}
			}
		} else if f.InerObject != nil {
			if f.IsRepeat {
				if g.config.LittleEndian {
					b.WriteString(fmt.Sprintf("    %s = codec::read_object_List_le<%s,%s>(buf);\n", fieldNameLowerCamel, listLenTyp.Name, f.GetType()))
				} else {
					b.WriteString(fmt.Sprintf("    %s = codec::read_object_List<%s,%s>(buf);\n", fieldNameLowerCamel, listLenTyp.Name, f.GetType()))
				}
			} else {
				b.WriteString(fmt.Sprintf("    %s.decode(buf);\n", fieldNameLowerCamel))
			}
		} else if _, ok := g.binModel.PacketsMap[f.GetType()]; ok {
			if f.IsRepeat {
				if g.config.LittleEndian {
					b.WriteString(fmt.Sprintf("    %s = codec::read_object_List_le<%s,%s>(buf);\n", fieldNameLowerCamel, listLenTyp.Name, f.GetType()))
				} else {
					b.WriteString(fmt.Sprintf("    %s = codec::read_object_List<%s,%s>(buf);\n", fieldNameLowerCamel, listLenTyp.Name, f.GetType()))
				}
			} else {
				b.WriteString(fmt.Sprintf("    %s.decode(buf);\n", fieldNameLowerCamel))
			}
		} else if f.GetType() == "match" {
			matchKeyLowerCamel := strcase.ToLowerCamel(f.MatchKey)
			b.WriteString(fmt.Sprintf("    %s = %sMessageFactory::getInstance().create(%s);\n", fieldNameLowerCamel, strcase.ToCamel(p.Name), matchKeyLowerCamel))
			b.WriteString(fmt.Sprintf("    %s->decode(buf);\n", fieldNameLowerCamel))
		} else {
			b.WriteString("-- unsupport type:" + f.GetType() + "\n")
		}
	}
	b.WriteString("}\n")
	return b.String()
}

func (g CppGenerator) generateToString(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("std::string toString() const override {\n")
	b.WriteString("    std::ostringstream oss;\n")
	b.WriteString("    oss << \"" + p.Name + " { \"\n")
	for i, field := range p.Fields {
		if i > 0 {
			b.WriteString("    << \", \"\n")
		}
		fieldNameLowerCamel := strcase.ToLowerCamel(field.Name)
		if field.IsRepeat {
			t := field.GetType()
			if typ, ok := cppBasicTypeMap[field.GetType()]; ok {
				t = typ.Name
			} else if _, ok := model.ParseCharArrayType(field.GetType()); ok {
				t = "std::string"
			} else if field.GetType() == "string" || field.GetType() == "char[]" {
				t = "std::string"
			}
			b.WriteString(fmt.Sprintf("    << \"%s: \" << codec::join_vector<%s>(%s)\n", field.Name, t, fieldNameLowerCamel))
			continue
		}
		if _, ok := cppBasicTypeMap[field.GetType()]; ok {
			switch field.GetType() {
			case "i8":
				b.WriteString(fmt.Sprintf("    << \"%s: \" << static_cast<int>(%s)\n", field.Name, fieldNameLowerCamel))
			case "u8":
				b.WriteString(fmt.Sprintf("    << \"%s: \" << static_cast<unsigned>(%s)\n", field.Name, fieldNameLowerCamel))
			case "f32", "f64":
				b.WriteString(fmt.Sprintf("    << \"%s: \" << std::fixed << std::setprecision(6) << %s\n", field.Name, fieldNameLowerCamel))
			default:
				b.WriteString(fmt.Sprintf("    << \"%s: \" << std::to_string(%s)\n", field.Name, fieldNameLowerCamel))
			}
			continue
		}
		if field.InerObject != nil {
			b.WriteString(fmt.Sprintf("    << \"%s: \" << %s.toString()\n", field.Name, fieldNameLowerCamel))
			continue
		}
		if _, ok := g.binModel.PacketsMap[field.GetType()]; ok {
			b.WriteString(fmt.Sprintf("    << \"%s: \" << %s.toString()\n", field.Name, fieldNameLowerCamel))
			continue
		}
		if field.GetType() == "match" {
			b.WriteString(fmt.Sprintf("    << \"%s: \" << %s->toString()\n", field.Name, fieldNameLowerCamel))
			continue
		}
		b.WriteString(fmt.Sprintf("    << \"%s: \" << %s\n", field.Name, fieldNameLowerCamel))
	}
	b.WriteString("    << \" }\";\n")
	b.WriteString("    return oss.str();\n")
	b.WriteString("}\n")
	return b.String()
}

func (g CppGenerator) generateOstreamOperator(p *model.Packet) string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("inline std::ostream& operator<<(std::ostream& os, const %s& pkt) {\n", p.Name))
	b.WriteString("    return os << pkt.toString();\n")
	b.WriteString("}\n")
	return b.String()
}

func (g CppGenerator) getFieldType(f *model.Field) string {
	typ := ""
	if t, ok := cppBasicTypeMap[f.GetType()]; ok {
		typ = t.Name
	} else if _, ok := model.ParseCharArrayType(f.GetType()); ok {
		typ = "std::string"
	} else {
		switch f.GetType() {
		case "match":
			typ = "std::unique_ptr<codec::BinaryCodec>"
		case "string", "char[]":
			typ = "std::string"
		default:
			typ = f.GetType()
		}
	}
	if f.IsRepeat {
		typ = "std::vector<" + typ + ">"
	}
	return typ
}

func (g CppGenerator) generateTestFile(binModel *model.BinaryModel) string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("// Copyright %d xinchentechnote\n", time.Now().Year()))
	b.WriteString("// Code generated by fin-protoc. DO NOT EDIT.\n")
	b.WriteString(fmt.Sprintf("#include \"include/%s.hpp\"\n", strcase.ToSnake(binModel.RootPacket.Name)))
	b.WriteString("#include <gtest/gtest.h>\n")
	b.WriteString("\n")

	for _, p := range binModel.Packets {
		b.WriteString(g.generateUnitestForPacket(p))
		b.WriteString("\n")
	}

	return b.String()
}

func (g CppGenerator) generateUnitestForPacket(p *model.Packet) string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("TEST(%sTest, EncodeAndDeocde) {\n", p.Name))
	b.WriteString(AddIndent4ln(g.generateNewInstance("original", p)))

	b.WriteString("    ByteBuf buf;\n")
	b.WriteString("    original.encode(buf);\n")
	b.WriteString(fmt.Sprintf("    %s decoded;\n", p.Name))
	b.WriteString("    decoded.decode(buf);\n")
	for _, f := range p.Fields {
		if f.LengthOfField != "" || f.CheckSumType != "" {
			b.WriteString(fmt.Sprintf("    original.%s = decoded.%s;\n", strcase.ToLowerCamel(f.Name), strcase.ToLowerCamel(f.Name)))
		}
	}
	b.WriteString("\n")
	b.WriteString("    EXPECT_TRUE(original == decoded);\n")
	b.WriteString("}\n")
	return b.String()
}

func (g CppGenerator) generateNewInstance(name string, p *model.Packet) string {
	var b strings.Builder
	for _, f := range p.Fields {
		fieldNameLowerCamel := strcase.ToLowerCamel(f.Name)
		if f.InerObject != nil {
			b.WriteString(g.generateNewInstance(fieldNameLowerCamel, f.InerObject))
			b.WriteString("\n")
		} else if mp, ok := g.binModel.PacketsMap[f.GetType()]; ok {
			b.WriteString(g.generateNewInstance(fieldNameLowerCamel, mp))
			b.WriteString("\n")
		} else if f.GetType() == "match" {
			mp := g.binModel.PacketsMap[f.MatchPairs[0].Value]
			b.WriteString(g.generateMakeUniqueInstance(fieldNameLowerCamel, mp))
			b.WriteString("\n")
		}
	}
	b.WriteString(fmt.Sprintf("%s %s;\n", strcase.ToCamel(p.Name), name))
	for _, f := range p.Fields {
		fieldNameLowerCamel := strcase.ToLowerCamel(f.Name)
		if f.GetType() == "match" {
			b.WriteString(fmt.Sprintf("%s.%s = %s;\n", name, strcase.ToLowerCamel(f.MatchKey), f.MatchPairs[0].Key))
			b.WriteString(fmt.Sprintf("%s.%s = std::move(%s);\n", name, fieldNameLowerCamel, g.generateTestValue(f)))
		} else {
			if _, ok := p.MatchFields[f.Name]; ok {
				continue
			}
			b.WriteString(fmt.Sprintf("%s.%s = %s;\n", name, fieldNameLowerCamel, g.generateTestValue(f)))
		}
	}
	return b.String()
}

func (g CppGenerator) generateMakeUniqueInstance(name string, p *model.Packet) string {
	var b strings.Builder
	for _, f := range p.Fields {
		fieldNameLowerCamel := strcase.ToLowerCamel(f.Name)
		if f.InerObject != nil {
			b.WriteString(g.generateNewInstance(fieldNameLowerCamel, f.InerObject))
			b.WriteString("\n")
		} else if mp, ok := g.binModel.PacketsMap[f.GetType()]; ok {
			b.WriteString(g.generateNewInstance(fieldNameLowerCamel, mp))
			b.WriteString("\n")
		} else if f.GetType() == "match" {
			b.WriteString(g.generateMakeUniqueInstance(fieldNameLowerCamel, mp))
			b.WriteString("\n")
		}
	}
	b.WriteString(fmt.Sprintf("auto %s = std::make_unique<%s>();\n", name, strcase.ToCamel(p.Name)))
	for _, f := range p.Fields {
		fieldNameLowerCamel := strcase.ToLowerCamel(f.Name)
		if f.GetType() == "match" {
			b.WriteString(fmt.Sprintf("%s->%s = std::move(%s);\n", name, fieldNameLowerCamel, g.generateTestValue(f)))
		} else {
			b.WriteString(fmt.Sprintf("%s->%s = %s;\n", name, fieldNameLowerCamel, g.generateTestValue(f)))
		}
	}
	return b.String()
}

func (g CppGenerator) generateTestValue(f *model.Field) any {
	tv := ""
	fieldNameLowerCamel := strcase.ToLowerCamel(f.Name)
	if typ, ok := cppBasicTypeMap[f.GetType()]; ok {
		tv = typ.TestValue
	} else if size, ok := model.ParseCharArrayType(f.GetType()); ok {
		tv = "\"" + strings.Repeat("x", size) + "\""
	} else if f.GetType() == "string" || f.GetType() == "char[]" {
		tv = "\"hello\""
	} else if f.InerObject != nil {
		tv = fieldNameLowerCamel
	} else if _, ok := g.binModel.PacketsMap[f.GetType()]; ok {
		tv = fieldNameLowerCamel
	} else if f.GetType() == "match" {
		tv = fieldNameLowerCamel
	} else {
		tv = "-- unsupport " + f.GetType()
	}

	if f.IsRepeat {
		return fmt.Sprintf("{%s}", tv)
	}
	return tv
}
