package parser

import (
	"fmt"
	"strings"
	"time"

	"github.com/iancoleman/strcase"
	"github.com/xinchentechnote/fin-protoc/internal/model"
)

// CppType represents a C++ type with its name, basic type, and size.
type CppType struct {
	Name      string
	BasicType string
	Size      int
}

var cppBaiscTypeMap = map[string]CppType{
	"i8":  {"int8_t", "int", 1},
	"i16": {"int16_t", "int", 2},
	"i32": {"int32_t", "int", 4},
	"i64": {"int64_t", "int", 8},
	"u8":  {"uint8_t", "unsigned int", 1},
	"u16": {"uint16_t", "unsigned int", 2},
	"u32": {"uint32_t", "unsigned int", 4},
	"u64": {"uint64_t", "unsigned int", 8},
	"f32": {"float", "float", 4},
	"f64": {"double", "double", 8},
}

// CppGenerator a go code generator
type CppGenerator struct {
	config   *GeneratorConfig
	binModel *model.BinaryModel
	hasGen   map[string]*model.Packet
}

// NewCppGenerator new
func NewCppGenerator(config *GeneratorConfig, binModel *model.BinaryModel) *CppGenerator {
	return &CppGenerator{
		config:   config,
		binModel: binModel,
		hasGen:   make(map[string]*model.Packet),
	}
}

// Generate go code
func (g CppGenerator) Generate(binModel *model.BinaryModel) (map[string][]byte, error) {
	output := make(map[string][]byte)
	var b strings.Builder
	b.WriteString(fmt.Sprintf("// Copyright %d xinchentechnote\n", time.Now().Year()))
	b.WriteString("// Code generated by fin-protoc. DO NOT EDIT.\n")
	b.WriteString("#pragma once\n")
	b.WriteString("#include <cstdint>\n")
	b.WriteString("#include <memory>\n")
	b.WriteString("#include <string>\n")
	b.WriteString("#include <vector>\n")
	b.WriteString("#include <iostream>\n")
	b.WriteString("#include \"include/codec.hpp\"\n")
	b.WriteString("#include \"include/bytebuf.hpp\"\n")
	b.WriteString("\n")
	code := g.generateHppFile(binModel)
	b.WriteString(code)
	output["include/"+strcase.ToSnake(binModel.RootPacket.Name)+".hpp"] = []byte(b.String())
	return output, nil
}

func (g CppGenerator) generateHppFile(binModel *model.BinaryModel) string {
	var b strings.Builder
	for _, pkt := range binModel.PacketsMap {
		code := g.generateCodeForPacket(&pkt)
		b.WriteString(code)
		b.WriteString("\n")
	}
	return b.String()
}

func (g CppGenerator) generateCodeForPacket(p *model.Packet) string {
	if _, ok := g.hasGen[p.Name]; ok {
		return ""
	}
	g.hasGen[p.Name] = p
	var b strings.Builder

	//iner
	for _, f := range p.Fields {
		if f.InerObject != nil {
			b.WriteString(g.generateCodeForPacket(f.InerObject))
			b.WriteString("\n")
		}
		if mp, ok := g.binModel.PacketsMap[f.GetType()]; ok {
			b.WriteString(g.generateCodeForPacket(&mp))
			b.WriteString("\n")
		}
	}
	//struct
	b.WriteString(fmt.Sprintf("struct %s : public codec::BinaryCodec {\n", p.Name))
	for _, field := range p.Fields {
		b.WriteString("    " + g.getFieldType(&field) + " " + strcase.ToLowerCamel(field.Name) + ";\n")
	}

	b.WriteString("\n")
	b.WriteString("    void encode(ByteBuf& buf) const override {}\n")
	b.WriteString("    void decode(ByteBuf& buf) override {}\n")

	//tostring
	b.WriteString("    std::string toString() const override {\n")
	b.WriteString("        std::string result = \"" + p.Name + " { \";\n")
	for i, field := range p.Fields {
		if i > 0 {
			b.WriteString("        result += \", \";\n")
		}
		if field.IsRepeat {
			b.WriteString(fmt.Sprintf("        result += \"%s: \" + codec::join_vector(%s);\n", field.Name, strcase.ToLowerCamel(field.Name)))
			continue
		}
		if _, ok := cppBaiscTypeMap[field.GetType()]; ok {
			b.WriteString(fmt.Sprintf("        result += \"%s: \" + std::to_string(%s);\n", field.Name, strcase.ToLowerCamel(field.Name)))
			continue
		}
		if field.InerObject != nil {
			b.WriteString(fmt.Sprintf("        result += \"%s: \" + %s.toString();\n", field.Name, strcase.ToLowerCamel(field.Name)))
			continue
		}
		if _, ok := g.binModel.PacketsMap[field.GetType()]; ok {
			b.WriteString(fmt.Sprintf("        result += \"%s: \" + %s.toString();\n", field.Name, strcase.ToLowerCamel(field.Name)))
			continue
		}
		if field.GetType() == "match" {
			b.WriteString(fmt.Sprintf("        result += \"%s: \" + %s->toString();\n", field.Name, strcase.ToLowerCamel(field.Name)))
			continue
		}
		b.WriteString(fmt.Sprintf("        result += \"%s: \" + %s;\n", field.Name, strcase.ToLowerCamel(field.Name)))
	}
	b.WriteString("        result += \" }\";\n")
	b.WriteString("        return result;\n")
	b.WriteString("    }\n")

	b.WriteString("};\n")

	// operator<< 实现
	b.WriteString("\n")
	b.WriteString(fmt.Sprintf("inline std::ostream& operator<<(std::ostream& os, const %s& pkt) {\n", p.Name))
	b.WriteString("    return os << pkt.toString();\n")
	b.WriteString("}\n")
	b.WriteString("\n")
	return b.String()
}

func (g CppGenerator) getFieldType(f *model.Field) string {
	typ := ""
	if t, ok := cppBaiscTypeMap[f.GetType()]; ok {
		typ = t.Name
	} else if _, ok := ParseCharArrayType(f.GetType()); ok {
		typ = "std::string"
	} else {
		switch f.GetType() {
		case "match":
			typ = "std::unique_ptr<codec::BinaryCodec>"
		case "string", "char[]":
			typ = "std::string"
		default:
			typ = f.GetType()
		}
	}
	if f.IsRepeat {
		typ = "std::vector<" + typ + ">"
	}
	return typ
}
