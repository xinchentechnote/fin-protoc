package parser

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/xinchentechnote/fin-protoc/internal/model"
)

// RustGenerator gen rust code
type RustGenerator struct {
	ListLenPrefix   string                  // Prefix for list length fields
	StringLenPrefix string                  // Prefix for string length fields
	Packets         map[string]model.Packet // Store packets by name
}

// GenerateCode code for packet
func (g RustGenerator) GenerateCode(msg model.Packet) string {
	var b strings.Builder

	// Rust use statements
	b.WriteString("// Code generated by fin-protoc. DO NOT EDIT.\n")
	b.WriteString("use binary_codec::*;\n")
	b.WriteString("use bytes::{Buf, BufMut, Bytes, BytesMut};\n\n")

	b.WriteString(g.GenerateUseCode(msg))
	b.WriteString("\n")
	b.WriteString(g.GenerateStructCode(msg))
	return b.String()
}

// GenerateStructCode generates Rust code for a struct based on the provided packet model.
func (g RustGenerator) GenerateStructCode(msg model.Packet) string {
	var b strings.Builder
	b.WriteString(g.GenerateMatchFieldEnumCode(msg))
	b.WriteString("\n")
	for _, f := range msg.Fields {
		if f.InerObject != nil {
			b.WriteString(g.GenerateStructCode(*f.InerObject))
			b.WriteString("\n")
		}
	}
	b.WriteString("\n")
	// struct
	structName := toRustStructName(msg.Name)
	b.WriteString("#[derive(Debug, Clone, PartialEq)]\n")
	b.WriteString(fmt.Sprintf("pub struct %s {\n", structName))
	for _, f := range msg.Fields {
		if f.IsRepeat {
			b.WriteString(fmt.Sprintf("    pub %s: Vec<%s>,\n", GetFieldName(f), GetFieldType(f)))
		} else {
			b.WriteString(fmt.Sprintf("    pub %s: %s,\n", GetFieldName(f), GetFieldType(f)))
		}
	}
	b.WriteString("}\n\n")

	// impl BinaryCodec
	b.WriteString(fmt.Sprintf("impl BinaryCodec for %s {\n", structName))

	// encode()
	b.WriteString("    fn encode(&self, buf: &mut BytesMut) {\n")
	for _, f := range msg.Fields {
		b.WriteString(fmt.Sprintf("        %s\n", g.EncodeField(f)))
	}
	b.WriteString("    }\n\n")

	// decode()
	b.WriteString(fmt.Sprintf("    fn decode(buf: &mut Bytes) -> Option<%s> {\n", structName))
	for _, f := range msg.Fields {
		b.WriteString(fmt.Sprintf("        %s\n", g.DecodeField(f)))
	}
	b.WriteString("        Some(Self {\n")
	for _, f := range msg.Fields {
		b.WriteString(fmt.Sprintf("            %s,\n", GetFieldName(f)))
	}
	b.WriteString("        })\n")
	b.WriteString("    }\n")
	b.WriteString("}\n")
	b.WriteString("\n")
	b.WriteString(g.GenerateTestCode(msg))
	return b.String()
}

// GenerateUseCode generates use statements for match pairs in the packet.
func (g RustGenerator) GenerateUseCode(msg model.Packet) string {
	var b strings.Builder
	for _, f := range msg.Fields {
		if f.GetType() == "match" {
			for _, pair := range f.MatchPairs {
				b.WriteString(fmt.Sprintf("use crate::%s::*;\n", toSnake(pair.Value)))
			}
		}
	}
	return b.String()
}

// assistant functions
// toSnake converts a CamelCase or PascalCase name to snake_case.
func toSnake(name string) string {
	return strcase.ToSnake(name)
}

// toRustStructName converts a name to CamelCase for Rust struct naming conventions.
func toRustStructName(name string) string {
	return strcase.ToCamel(name) // Rust structs ç”¨ CamelCase
}

// GetFieldType convert field type for rust
func GetFieldType(f model.Field) string {
	switch f.GetType() {
	case "string":
		return "String"
	case "match":
		return f.MatchType
	default:
		pattern := `^char\[(\d+)\]$`
		re := regexp.MustCompile(pattern)
		if re.MatchString(f.GetType()) {
			return "String"
		}
		return f.GetType()

	}
}

// GetFieldName returns the field name in snake_case format.
func GetFieldName(f model.Field) string {
	switch f.GetType() {
	case "match":
		return toSnake(f.Name) + "_body"
	default:
		return toSnake(f.Name)

	}
}

// EncodeField encoding field
func (g RustGenerator) EncodeField(f model.Field) string {
	name := toSnake(f.Name)
	if f.IsRepeat {
		if f.GetType() == "string" {
			return fmt.Sprintf("put_string_list::<%s,%s>(buf, &self.%s);", g.ListLenPrefix, g.StringLenPrefix, name)
		}
		size, ok := parseCharArrayType(f.GetType())
		if ok {
			return fmt.Sprintf("put_fixed_string_list::<%s>(buf, &self.%s, %s);", g.ListLenPrefix, name, size)
		}
		return fmt.Sprintf("put_list::<%s,%s>(buf, &self.%s);", f.GetType(), g.ListLenPrefix, name)
	}
	switch f.GetType() {
	case "string":
		return fmt.Sprintf("put_%s(buf, &self.%s);", f.GetType(), name)
	case "char":
		return fmt.Sprintf("put_%s(buf, self.%s);", f.GetType(), name)
	case "u8", "u16", "u32", "u64", "i8", "i16", "i32", "i64":
		return fmt.Sprintf("buf.put_%s(self.%s);", f.GetType(), name)
	case "match":
		return EncoderMatchField(f)
	default:
		size, ok := parseCharArrayType(f.GetType())
		if ok {
			return fmt.Sprintf("put_char_array(buf, &self.%s, %s);", name, size)
		}
		if f.InerObject != nil {
			// If it's a nested object, we need to encode it
			return fmt.Sprintf("self.%s.encode(buf);", GetFieldName(f))

		}
		return fmt.Sprintf("// unknown type for encode: %s", f.GetType())
	}
}

// EncoderMatchField encodes match field
func EncoderMatchField(f model.Field) string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("match &self.%s {\n", GetFieldName(f)))
	for _, pair := range f.MatchPairs {
		b.WriteString(fmt.Sprintf("  %s::%s(msg) => msg.encode(buf),\n", f.MatchType, pair.Value))
	}
	b.WriteString("}")
	return b.String()
}

// DecodeField decoding field
func (g RustGenerator) DecodeField(f model.Field) string {
	name := toSnake(f.Name)
	if f.IsRepeat {
		if f.GetType() == "string" {
			return fmt.Sprintf("let %s = get_string_list::<%s,%s>(buf)?;", name, g.ListLenPrefix, g.StringLenPrefix)
		}
		size, ok := parseCharArrayType(f.GetType())
		if ok {
			return fmt.Sprintf("let %s = get_fixed_string_list::<%s>(buf, %s)?;", name, g.ListLenPrefix, size)
		}
		return fmt.Sprintf("let %s = get_list::<%s,%s>(buf)?;", name, f.GetType(), g.ListLenPrefix)
	}
	switch f.GetType() {
	case "string", "char":
		return fmt.Sprintf("let %s = get_%s(buf)?;", name, f.GetType())
	case "u8", "u16", "u32", "u64", "i8", "i16", "i32", "i64":
		return fmt.Sprintf("let %s = buf.get_%s();", name, f.GetType())
	case "match":
		return DecodeMatchField(f)
	default:
		pattern := `^char\[(\d+)\]$`
		re := regexp.MustCompile(pattern)
		matches := re.FindStringSubmatch(f.GetType())
		if len(matches) == 2 {
			size := matches[1]
			return fmt.Sprintf("let %s = get_char_array(buf, %s)?;", name, size)
		}
		if f.InerObject != nil {
			// If it's a nested object, we need to decode it
			return fmt.Sprintf("let %s = %s::decode(buf)?;", GetFieldName(f), f.InerObject.Name)
		}
		return fmt.Sprintf("// unknown type for decode: %s", f.GetType())
	}
}

// DecodeMatchField decodes match field
func DecodeMatchField(f model.Field) string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("let %s_body = match %s {\n", toSnake(f.Name), toSnake(f.Name)))
	for _, pair := range f.MatchPairs {
		b.WriteString(fmt.Sprintf("  %s => %s::%s(%s::decode(buf)?),\n", pair.Key, f.MatchType, pair.Value, pair.Value))
	}
	b.WriteString(" _ => return None,\n")
	b.WriteString("};")
	return b.String()
}

// FileExtension rust file extension
func (RustGenerator) FileExtension() string {
	return ".rs"
}

// GenerateMatchFieldEnumCode to enum
func (g RustGenerator) GenerateMatchFieldEnumCode(packet model.Packet) string {
	var b strings.Builder
	for _, f := range packet.Fields {
		if f.GetType() == "match" {
			b.WriteString("#[derive(Debug, Clone, PartialEq)]")
			b.WriteString(fmt.Sprintf("pub enum %s {\n", f.MatchType))
			for _, pair := range f.MatchPairs {
				b.WriteString(fmt.Sprintf("    %s(%s),\n", pair.Value, pair.Value))
			}
			b.WriteString("}\n\n")
		}
	}
	return b.String()
}

// GenerateTestCode gen unit test code
func (g RustGenerator) GenerateTestCode(packet model.Packet) string {
	var b strings.Builder

	structName := toRustStructName(packet.Name)
	instanceName := strcase.ToSnake(packet.Name)

	b.WriteString(fmt.Sprintf("#[cfg(test)]\nmod %s_tests {\n", instanceName))
	b.WriteString("    use super::*;\n")
	b.WriteString("    use bytes::BytesMut;\n")

	b.WriteString(g.GenerateUseCodeForTest() + "\n\n")

	b.WriteString("    #[test]\n")
	b.WriteString(fmt.Sprintf("    fn test_%s_codec() {\n", instanceName))

	// new instance
	b.WriteString(fmt.Sprintf("        let original = %s {\n", structName))
	for _, f := range packet.Fields {
		if packet.MatchFields[f.Name] != nil {
			if len(f.MatchPairs) > 0 {
				b.WriteString(fmt.Sprintf("            %s: %s,\n", toSnake(f.Name), f.MatchPairs[0].Key))
				b.WriteString(fmt.Sprintf("            %s: %s,\n", GetFieldName(f), g.TestValue(f)))
			}
			continue
		}
		b.WriteString(fmt.Sprintf("            %s: %s,\n", GetFieldName(f), g.TestValue(f)))
	}
	b.WriteString("        };\n\n")

	// encoding
	b.WriteString("        let mut buf = BytesMut::new();\n")
	b.WriteString("        original.encode(&mut buf);\n")
	b.WriteString("        let mut bytes = buf.freeze();\n\n")

	// decoding
	b.WriteString(fmt.Sprintf("        let decoded = %s::decode(&mut bytes).unwrap();\n\n", structName))

	// assertion
	b.WriteString("        assert_eq!(original, decoded);\n")
	b.WriteString("    }\n")
	b.WriteString("}\n")

	return b.String()
}

// GenerateUseCodeForTest gen for test mod
func (g RustGenerator) GenerateUseCodeForTest() string {
	var b strings.Builder
	for name := range g.Packets {
		b.WriteString(fmt.Sprintf("    use crate::%s::*;\n", toSnake(name)))
	}
	return b.String()
}

// parseCharArrayType parse char[\d]
func parseCharArrayType(fieldType string) (size string, ok bool) {
	pattern := `^char\[(\d+)\]$`
	matches := regexp.MustCompile(pattern).FindStringSubmatch(fieldType)
	if len(matches) == 2 {
		return matches[1], true
	}
	return "", false
}

// TestValue gen test value for deferent field type
func (g RustGenerator) TestValue(f model.Field) string {
	if f.IsRepeat {
		return testValueList(f.GetType())
	}

	return g.testValueSingle(f)
}

func testValueList(typ string) string {
	if val, ok := primitiveListValues()[typ]; ok {
		return val
	}
	size, ok := parseCharArrayType(typ)
	if ok {
		return fmt.Sprintf("vec![\"a\".to_string(); %s]", size)
	}
	return "vec![]"
}

func (g RustGenerator) testValueSingle(f model.Field) string {
	typ := f.GetType()

	// handle match
	if typ == "match" {
		return g.testMatchValue(f)
	}

	// handle char[n]
	size, ok := parseCharArrayType(f.GetType())
	if ok {
		return fmt.Sprintf("vec!['a'; %s].into_iter().collect::<String>()", size)
	}

	// handle primitive
	if val, ok := primitiveSingleValues()[typ]; ok {
		return val
	}

	if f.InerObject != nil {
		// If it's a nested object, we need to create a default instance
		var fieldValues []string
		for _, subField := range f.InerObject.Fields {
			fieldValues = append(fieldValues, fmt.Sprintf("%s: %s", toSnake(subField.Name), g.TestValue(subField)))
		}
		return fmt.Sprintf("%s{\n %s \n}", toRustStructName(f.InerObject.Name), strings.Join(fieldValues, ",\n"))
	}

	return "Default::default()"
}

func primitiveListValues() map[string]string {
	return map[string]string{
		"string": `vec!["example".to_string(), "test".to_string()]`,
		"char":   `vec!['a','b']`,
		"u8":     "vec![42,12]",
		"u16":    "vec![1234,4321]",
		"u32":    "vec![123456,654321]",
		"u64":    "vec![123456789,987654321]",
		"i8":     "vec![-42,-12]",
		"i16":    "vec![-1234,-4321]",
		"i32":    "vec![-123456,-654321]",
		"i64":    "vec![-123456789,-987654321]",
	}
}

func primitiveSingleValues() map[string]string {
	return map[string]string{
		"string": `"example".to_string()`,
		"char":   `'a'`,
		"u8":     "42",
		"u16":    "1234",
		"u32":    "123456",
		"u64":    "123456789",
		"i8":     "-42",
		"i16":    "-1234",
		"i32":    "-123456",
		"i64":    "-123456789",
	}
}

func (g RustGenerator) testMatchValue(f model.Field) string {
	if len(f.MatchPairs) == 0 {
		return fmt.Sprintf("%s::default()", f.MatchType)
	}

	matchName := f.MatchPairs[0].Value
	subPacket := g.Packets[matchName]
	var innerFields []string
	for _, subField := range subPacket.Fields {
		innerFields = append(innerFields,
			fmt.Sprintf("%s: %s", toSnake(subField.Name), g.TestValue(subField)))
	}
	return fmt.Sprintf("%s::%s(%s { \n %s \n })",
		f.MatchType,
		matchName,
		matchName,
		strings.Join(innerFields, ", \n "),
	)
}
