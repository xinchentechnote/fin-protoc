package parser

import (
	"fmt"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/xinchentechnote/fin-protoc/internal/model"
)

// JavaType java basic type
type JavaType struct {
	Name      string
	BasicType string
	BoxType   string
	TestValue string
	Le        string
	Size      uint32
}

// javaBasicTypeMap dsl basic type to java type
var javaBasicTypeMap = map[string]JavaType{
	// 无符号整数类型
	"u8": {
		Name:      "u8",
		BasicType: "byte",
		BoxType:   "Byte",
		Le:        "Byte",
		Size:      1,
		TestValue: "(byte)1",
	},
	"char": {
		Name:      "char",
		BasicType: "byte",
		BoxType:   "Byte",
		Le:        "Byte",
		Size:      1,
		TestValue: "(byte)1",
	},
	"u16": {
		Name:      "u16",
		BasicType: "short",
		BoxType:   "Short",
		Le:        "ShortLE",
		Size:      2,
		TestValue: "(short)2",
	},
	"u32": {
		Name:      "u32",
		BasicType: "int",
		BoxType:   "Integer",
		Le:        "IntLE",
		Size:      4,
		TestValue: "4",
	},
	"u64": {
		Name:      "u64",
		BasicType: "long",
		BoxType:   "Long",
		Le:        "LongLE",
		Size:      8,
		TestValue: "8L",
	},

	// 有符号整数类型
	"i8": {
		Name:      "i8",
		BasicType: "byte",
		BoxType:   "Byte",
		Le:        "Byte",
		Size:      1,
		TestValue: "(byte)1",
	},
	"i16": {
		Name:      "i16",
		BasicType: "short",
		BoxType:   "Short",
		Le:        "ShortLE",
		Size:      2,
		TestValue: "(short)2",
	},
	"i32": {
		Name:      "i32",
		BasicType: "int",
		BoxType:   "Integer",
		Le:        "IntLE",
		Size:      4,
		TestValue: "4",
	},
	"i64": {
		Name:      "i64",
		BasicType: "long",
		BoxType:   "Long",
		Le:        "LongLE",
		Size:      8,
		TestValue: "8L",
	},

	// 浮点类型
	"f32": {
		Name:      "f32",
		BasicType: "float",
		BoxType:   "Float",
		Le:        "FloatLE",
		Size:      4,
		TestValue: "4F",
	},
	"f64": {
		Name:      "f64",
		BasicType: "double",
		BoxType:   "Double",
		Le:        "DoubleLE",
		Size:      8,
		TestValue: "8D",
	},
}

// JavaGenerator a java code generator
type JavaGenerator struct {
	binModel *model.BinaryModel
}

// NewJavaGenerator new
func NewJavaGenerator(binModel *model.BinaryModel) *JavaGenerator {
	return &JavaGenerator{
		binModel: binModel,
	}
}

// GetConfig get Configuration
func (g JavaGenerator) GetConfig() *model.Configuration {
	return g.binModel.Config
}

// Generate gen hava code entry
func (g JavaGenerator) Generate(binModel *model.BinaryModel) (map[string][]byte, error) {
	output := make(map[string][]byte)
	packagePath := strings.ReplaceAll(g.GetConfig().JavaPackage, ".", "/")
	for _, pkg := range binModel.PacketsMap {
		//gen message class
		code := g.GenerateJavaClassFileForPacket(pkg, false)
		filePath := fmt.Sprintf("main/java/%s/%s.java", packagePath, pkg.Name)
		output[filePath] = []byte(code)
		//gen unit test class
		code = g.GenerateJavaTestClassFileForPacket(pkg)
		filePath = fmt.Sprintf("test/java/%s/%sTest.java", packagePath, pkg.Name)
		output[filePath] = []byte(code)
	}
	return output, nil
}

// GenerateJavaClassFileForPacket gen java class file
func (g JavaGenerator) GenerateJavaClassFileForPacket(packet *model.Packet, isInerClass bool) string {
	var b strings.Builder
	b.WriteString("// Code generated by fin-protoc. DO NOT EDIT.\n")
	if !isInerClass {
		//package
		b.WriteString(fmt.Sprintf("package %s;\n", g.GetConfig().JavaPackage))
		//import
		b.WriteString(`
import com.finproto.codec.ChecksumService;
import com.finproto.codec.ChecksumServiceFactory;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.function.Supplier;
import com.finproto.codec.BinaryCodec;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.util.internal.StringUtil;
`)
		b.WriteString("\n")
		b.WriteString("\n")
	}
	static := ""
	if isInerClass {
		static = " static"
	}
	//class
	b.WriteString(fmt.Sprintf("public%s class %s implements BinaryCodec {\n", static, packet.Name))
	//field
	for _, f := range packet.Fields {
		b.WriteString(AddIndent4ln(fmt.Sprintf("private %s %s;", g.GetFieldType(f), g.GetFieldNameLower(f))))
	}
	b.WriteString("\n")

	//get and set
	for _, f := range packet.Fields {
		b.WriteString(AddIndent4ln(g.GenerateGetterAndSetter(f)))
	}
	b.WriteString("\n")

	//encode
	b.WriteString(AddIndent4ln(g.GenerateEncode(packet)))
	b.WriteString("\n")
	//decode
	b.WriteString(AddIndent4ln(g.GenerateDecode(packet)))

	b.WriteString("\n")
	//hashcode and equals
	b.WriteString(AddIndent4ln(g.GenerateHashCode(packet)))
	b.WriteString(AddIndent4ln(g.GenerateEquals(packet)))

	b.WriteString("\n")
	//tostring
	b.WriteString(AddIndent4ln(g.GenerateToString(packet)))
	//inerClass
	for _, f := range packet.Fields {
		if of, ok := f.Attr.(*model.ObjectFieldAttribute); ok && of.IsIner {
			b.WriteString(AddIndent4ln(g.GenerateJavaClassFileForPacket(of.RefPacket, true)))
		}
	}

	b.WriteString("\n")
	//message factory for match field
	for _, f := range packet.Fields {
		if mf, ok := f.Attr.(*model.MatchFieldAttribute); ok {
			b.WriteString(AddIndent4ln(g.GenerateMessageFactory(packet, f, mf)))
		}
	}
	b.WriteString("\n")
	b.WriteString("}")
	return b.String()
}

// GenerateMessageFactory gen message factory for match field
func (g JavaGenerator) GenerateMessageFactory(p *model.Packet, f *model.Field, mf *model.MatchFieldAttribute) string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("public static enum %sMessageFactory {\n", g.GetFieldName(f)))
	b.WriteString("    INSTANCE;\n")
	typ := p.FieldMap[mf.MatchKeyField.Name].GetType()
	matchKeyTyp, ok := javaBasicTypeMap[typ]
	cast := ""
	if ok {
		typ = matchKeyTyp.BoxType
		cast = fmt.Sprintf("(%s) ", matchKeyTyp.BasicType)
	}
	if typ == "string" {
		typ = "String"
	}
	b.WriteString(fmt.Sprintf("private final Map<%s, Supplier<BinaryCodec>> %sMap = new HashMap<>();", typ, g.GetFieldNameLower(f)))
	b.WriteString("\n")
	b.WriteString("static {\n")
	for _, pair := range mf.MatchPairs {
		b.WriteString(fmt.Sprintf("    getInstance().register(%s%s, %s::new);\n", cast, pair.Key, pair.Value))
	}
	b.WriteString("}\n")
	b.WriteString("\n")
	b.WriteString(fmt.Sprintf("public BinaryCodec create(%s %s) {\n", typ, strcase.ToLowerCamel(mf.MatchKeyField.Name)))
	b.WriteString(fmt.Sprintf("    Supplier<BinaryCodec> supplier = %sMap.get(%s);\n", g.GetFieldNameLower(f), strcase.ToLowerCamel(mf.MatchKeyField.Name)))
	b.WriteString("    if (null == supplier) {\n")
	b.WriteString(fmt.Sprintf("        throw new IllegalArgumentException(\"Unsupported %s:\" + %s);\n", mf.MatchKeyField.Name, strcase.ToLowerCamel(mf.MatchKeyField.Name)))
	b.WriteString("    }\n")
	b.WriteString("    return supplier.get();\n")
	b.WriteString("}")

	b.WriteString("\n")
	//register method
	b.WriteString(fmt.Sprintf("public void register(%s %s, Supplier<BinaryCodec> supplier) {\n", typ, strcase.ToLowerCamel(mf.MatchKeyField.Name)))
	b.WriteString(fmt.Sprintf("    %sMap.put(%s, supplier);\n", g.GetFieldNameLower(f), strcase.ToLowerCamel(mf.MatchKeyField.Name)))
	b.WriteString("}")
	b.WriteString("\n")
	//remove method
	b.WriteString(fmt.Sprintf("public boolean remove(%s %s) {\n", typ, strcase.ToLowerCamel(mf.MatchKeyField.Name)))
	b.WriteString(fmt.Sprintf("    return null != %sMap.remove(%s);\n", g.GetFieldNameLower(f), strcase.ToLowerCamel(mf.MatchKeyField.Name)))
	b.WriteString("}")
	b.WriteString("\n")
	//getInstance method
	b.WriteString("public static " + g.GetFieldName(f) + "MessageFactory getInstance() {\n")
	b.WriteString("    return INSTANCE;\n")
	b.WriteString("}\n")
	b.WriteString("}")

	return b.String()
}

// GetFieldName get CamelName
func (g JavaGenerator) GetFieldName(f *model.Field) string {
	return strcase.ToCamel(f.Name)
}

// GetFieldNameLower get lower CamelName
func (g JavaGenerator) GetFieldNameLower(f *model.Field) string {
	return strcase.ToLowerCamel(g.GetFieldName(f))
}

// GetPadding field.Padding or config.Padding
func (g JavaGenerator) GetPadding(f *model.Field) *model.Padding {
	padding := g.GetConfig().Padding
	if fs, ok := f.Attr.(*model.FixedStringFieldAttribute); ok {
		if fs.Padding != nil {
			padding = fs.Padding
		}
	}
	if padding == nil {
		return nil
	}
	// if PadChar is '\x00' or '\u0000' or "\0"，convert in Java '\0'
	if padding.PadChar == "'\x00'" || padding.PadChar == "'\u0000'" || padding.PadChar == "'\\x00'" {
		padding.PadChar = "'\\0'"
	}
	return padding
}

// GetFieldType get java type
func (g JavaGenerator) GetFieldType(f *model.Field) string {
	switch c := f.Attr.(type) {
	case *model.ObjectFieldAttribute:
		if f.IsRepeat {
			return fmt.Sprintf("List<%s>", c.PacketName)
		}
		return c.PacketName
	case *model.MatchFieldAttribute:
		return "BinaryCodec"
	case *model.LengthFieldAttribute, *model.CheckSumFieldAttribute, *model.BasicFieldAttribute:
		if f.IsRepeat {
			return fmt.Sprintf("List<%s>", javaBasicTypeMap[f.GetType()].BoxType)
		}
		return javaBasicTypeMap[f.GetType()].BasicType
	case *model.DynamicStringFieldAttribute, *model.FixedStringFieldAttribute:
		if f.IsRepeat {
			return "List<String>"
		}
		return "String"
	default:
		return "unkown type"
	}
}

// GenerateGetterAndSetter gen getter and setter method
func (g JavaGenerator) GenerateGetterAndSetter(f *model.Field) string {
	var b strings.Builder
	fieldNameCamel := g.GetFieldName(f)
	b.WriteString(fmt.Sprintf("public %s get%s() {\n", g.GetFieldType(f), fieldNameCamel))
	fieldNameLowerCamel := g.GetFieldNameLower(f)
	b.WriteString(AddIndent4ln(fmt.Sprintf("return this.%s;", fieldNameLowerCamel)))
	b.WriteString("}\n")
	b.WriteString("\n")
	b.WriteString("\n")
	b.WriteString(fmt.Sprintf("public void set%s(%s %s) {\n", fieldNameCamel, g.GetFieldType(f), fieldNameLowerCamel))
	b.WriteString(AddIndent4ln(fmt.Sprintf("this.%s = %s;", fieldNameLowerCamel, fieldNameLowerCamel)))
	b.WriteString("}\n")
	return b.String()
}

// GenerateToString gen toString method
func (g JavaGenerator) GenerateToString(packet *model.Packet) string {
	var b strings.Builder
	b.WriteString("@Override\n")
	b.WriteString("public String toString() {\n")
	if len(packet.Fields) > 0 {
		b.WriteString(AddIndent4(fmt.Sprintf("return \"%s [\"", packet.Name)))
		for idx, f := range packet.Fields {
			fieldNameLowerCamel := g.GetFieldNameLower(f)
			if idx == 0 {
				b.WriteString(fmt.Sprintf(" + \"%s=\" + this.%s", fieldNameLowerCamel, fieldNameLowerCamel))
			} else {
				b.WriteString(fmt.Sprintf(" + \", %s=\" + this.%s", fieldNameLowerCamel, fieldNameLowerCamel))
			}
		}
		b.WriteString(" + \"]\";\n")
	} else {
		b.WriteString(AddIndent4(fmt.Sprintf("return \"%s []\";", packet.Name)))
	}
	b.WriteString("}\n")
	return b.String()
}

// GenerateEquals gen equals method
func (g JavaGenerator) GenerateEquals(packet *model.Packet) string {
	var b strings.Builder
	b.WriteString("@Override\n")
	b.WriteString("public boolean equals(Object obj) {\n")
	b.WriteString(AddIndent4ln("if(this == obj) {"))
	b.WriteString(AddIndent4ln(AddIndent4("return true;")))
	b.WriteString(AddIndent4ln("}"))
	b.WriteString(AddIndent4ln("if(null == obj || getClass() != obj.getClass()) {"))
	b.WriteString(AddIndent4ln(AddIndent4("return false;")))
	b.WriteString(AddIndent4ln("}"))
	if len(packet.Fields) > 0 {
		b.WriteString(AddIndent4ln(fmt.Sprintf("%s orther_ = (%s) obj;", packet.Name, packet.Name)))
		equals := make([]string, 0, len(packet.Fields))
		for _, f := range packet.Fields {
			fieldNameLowerCamel := strcase.ToLowerCamel(f.Name)
			equal := fmt.Sprintf("Objects.equals(%s, orther_.%s)",
				fieldNameLowerCamel, fieldNameLowerCamel)
			equals = append(equals, equal)
		}
		b.WriteString(AddIndent4ln(fmt.Sprintf("return %s;", strings.Join(equals, " && "))))
	} else {
		b.WriteString(AddIndent4ln("return true;"))
	}
	b.WriteString("}\n")
	return b.String()
}

// GenerateHashCode gen hasCode method
func (g JavaGenerator) GenerateHashCode(packet *model.Packet) string {
	var b strings.Builder
	b.WriteString("@Override\n")
	b.WriteString("public int hashCode() {\n")
	if len(packet.Fields) > 0 {
		names := make([]string, 0, len(packet.Fields))
		for _, f := range packet.Fields {
			names = append(names, strcase.ToLowerCamel(f.Name))
		}
		b.WriteString(AddIndent4ln(fmt.Sprintf("return Objects.hash(%s);", strings.Join(names, ", "))))
	} else {
		b.WriteString(AddIndent4ln("return this.hashCode();"))
	}

	b.WriteString("}\n")
	return b.String()
}

// GenerateDecode gen decode method
func (g JavaGenerator) GenerateDecode(packet *model.Packet) string {
	var b strings.Builder
	b.WriteString("@Override\n")
	b.WriteString("public void decode(ByteBuf byteBuf) {\n")
	for _, f := range packet.Fields {
		if f.IsRepeat {
			fieldLen := g.GetFieldNameLower(f) + "Size"
			lenTyp := javaBasicTypeMap[g.GetConfig().ListLenPrefixLenType]
			if g.GetConfig().LittleEndian {
				b.WriteString(fmt.Sprintf("%s %s = byteBuf.read%s();\n", lenTyp.BasicType, fieldLen, lenTyp.Le))
			} else {
				b.WriteString(fmt.Sprintf("%s %s = byteBuf.read%s();\n", lenTyp.BasicType, fieldLen, strcase.ToCamel(lenTyp.BasicType)))
			}
			b.WriteString(AddIndent4ln(fmt.Sprintf("if(%s > 0) {", fieldLen)))
			b.WriteString(AddIndent4ln(fmt.Sprintf("this.%s = new ArrayList<>();", strcase.ToLowerCamel(f.Name))))
			b.WriteString(AddIndent4ln(fmt.Sprintf("for(int i=0;i<%s;i++) {", fieldLen)))
			b.WriteString(AddIndent4ln(g.GenerateDecodeField(f)))
			b.WriteString(AddIndent4ln("}"))
			b.WriteString(AddIndent4ln("}"))
		} else {
			b.WriteString(AddIndent4ln(g.GenerateDecodeField(f)))
		}
	}
	b.WriteString("}\n")
	return b.String()
}

// GenerateDecodeField den decode field
func (g JavaGenerator) GenerateDecodeField(f *model.Field) string {
	fieldNameLowerCamel := g.GetFieldNameLower(f)
	switch c := f.Attr.(type) {
	case *model.DynamicStringFieldAttribute:
		// dynamic string
		var b strings.Builder
		fieldLen := fieldNameLowerCamel + "Len"
		lenTyp := javaBasicTypeMap[g.GetConfig().StringLenPrefixLenType]
		if g.GetConfig().LittleEndian {
			b.WriteString(fmt.Sprintf("%s %s = byteBuf.read%s();\n", lenTyp.BasicType, fieldLen, lenTyp.Le))
		} else {
			b.WriteString(fmt.Sprintf("%s %s = byteBuf.read%s();\n", lenTyp.BasicType, fieldLen, strcase.ToCamel(lenTyp.BasicType)))
		}
		b.WriteString(fmt.Sprintf("if (%s > 0) {\n", fieldLen))
		if f.IsRepeat {
			b.WriteString(AddIndent4ln(fmt.Sprintf("this.%s.add(byteBuf.readCharSequence(%s, StandardCharsets.UTF_8).toString());", fieldNameLowerCamel, fieldLen)))
		} else {
			b.WriteString(AddIndent4ln(fmt.Sprintf("this.%s = byteBuf.readCharSequence(%s, StandardCharsets.UTF_8).toString();", fieldNameLowerCamel, fieldLen)))
		}
		b.WriteString("}")
		return b.String()
	case *model.FixedStringFieldAttribute:
		//fixed string
		len := c.Length
		padding := g.GetPadding(f)
		if !padding.IsDefault() {
			if f.IsRepeat {
				return fmt.Sprintf("this.%s.add(readFixedString(byteBuf, %d, %s, %t));", fieldNameLowerCamel, len, padding.PadChar, padding.PadLeft)
			}
			return fmt.Sprintf("this.%s = readFixedString(byteBuf, %d, %s, %t);", fieldNameLowerCamel, len, padding.PadChar, padding.PadLeft)
		}
		if f.IsRepeat {
			return fmt.Sprintf("this.%s.add(readFixedString(byteBuf, %d));", fieldNameLowerCamel, len)
		}
		return fmt.Sprintf("this.%s = readFixedString(byteBuf, %d);", fieldNameLowerCamel, len)
	case *model.ObjectFieldAttribute:
		if c.IsIner {
			//iner object
			var b strings.Builder
			fieldName := strcase.ToLowerCamel(c.RefPacket.Name)
			if f.IsRepeat {
				b.WriteString(fmt.Sprintf("%s %s_ = new %s();", f.GetType(), fieldName, f.GetType()))
				b.WriteString(fmt.Sprintf("%s_.decode(byteBuf);", fieldName))
				b.WriteString(fmt.Sprintf("this.%s.add(%s_);", fieldName, fieldName))
			} else {
				b.WriteString(fmt.Sprintf("if (null == this.%s) {\n", fieldName))
				b.WriteString(AddIndent4ln(fmt.Sprintf("this.%s = new %s();", fieldName, f.Name)))
				b.WriteString("}\n")
				b.WriteString(fmt.Sprintf("this.%s.decode(byteBuf);", fieldName))
			}
			return b.String()
		}
		//ref object
		var b strings.Builder
		fieldNameLowerCamel := strcase.ToLowerCamel(f.Name)
		if f.IsRepeat {
			b.WriteString(fmt.Sprintf("%s %s_ = new %s();", f.GetType(), fieldNameLowerCamel, f.GetType()))
			b.WriteString(fmt.Sprintf("%s_.decode(byteBuf);", fieldNameLowerCamel))
			b.WriteString(fmt.Sprintf("this.%s.add(%s_);", fieldNameLowerCamel, fieldNameLowerCamel))
		} else {
			b.WriteString(fmt.Sprintf("if (null == this.%s) {\n", fieldNameLowerCamel))
			b.WriteString(AddIndent4ln(fmt.Sprintf("this.%s = new %s();", fieldNameLowerCamel, f.Name)))
			b.WriteString("}\n")
			b.WriteString(fmt.Sprintf("this.%s.decode(byteBuf);", fieldNameLowerCamel))
		}
		return b.String()
	case *model.MatchFieldAttribute:
		//match field
		var b strings.Builder
		fieldNameCamel := g.GetFieldName(f)
		b.WriteString(fmt.Sprintf("this.%s = %sMessageFactory.getInstance().create(this.%s);\n", fieldNameLowerCamel, fieldNameCamel, strcase.ToLowerCamel(c.MatchKeyField.Name)))
		b.WriteString(fmt.Sprintf("this.%s.decode(byteBuf);", fieldNameLowerCamel))
		return b.String()
	case *model.BasicFieldAttribute, *model.LengthFieldAttribute, *model.CheckSumFieldAttribute:
		typ := javaBasicTypeMap[f.GetType()]
		//basic type
		readMethod := strcase.ToCamel(typ.BasicType)
		if g.GetConfig().LittleEndian {
			readMethod = typ.Le
		}
		if f.IsRepeat {
			return fmt.Sprintf("this.%s.add(byteBuf.read%s());", fieldNameLowerCamel, readMethod)
		}
		return fmt.Sprintf("this.%s = byteBuf.read%s();", fieldNameLowerCamel, readMethod)
	default:
		return "//TODO unknow"
	}
}

// GenerateEncode gen encode  method
func (g JavaGenerator) GenerateEncode(packet *model.Packet) string {
	var b strings.Builder
	b.WriteString("@Override\n")
	b.WriteString("public void encode(ByteBuf byteBuf) {\n")
	for _, f := range packet.Fields {
		if f.IsRepeat {
			lenTyp := javaBasicTypeMap[g.GetConfig().ListLenPrefixLenType]
			fieldNameLowerCamel := g.GetFieldNameLower(f)
			b.WriteString(AddIndent4ln(fmt.Sprintf("if (null == this.%s || this.%s.size() == 0) {", fieldNameLowerCamel, fieldNameLowerCamel)))
			b.WriteString(AddIndent4ln(AddIndent4(fmt.Sprintf("byteBuf.write%s(0);", strcase.ToCamel(lenTyp.BasicType)))))
			b.WriteString(AddIndent4ln("} else {"))
			cast := fmt.Sprintf("(%s) ", lenTyp.BasicType)
			if g.GetConfig().LittleEndian {
				b.WriteString(AddIndent4ln(AddIndent4(fmt.Sprintf("byteBuf.write%s(%sthis.%s.size());", lenTyp.Le, cast, fieldNameLowerCamel))))
			} else {
				b.WriteString(AddIndent4ln(AddIndent4(fmt.Sprintf("byteBuf.write%s(%sthis.%s.size());", strcase.ToCamel(lenTyp.BasicType), cast, fieldNameLowerCamel))))
			}
			b.WriteString(AddIndent4ln(AddIndent4(fmt.Sprintf("for (int i = 0; i < this.%s.size(); i++) {", fieldNameLowerCamel))))
			b.WriteString(AddIndent4ln(AddIndent4(AddIndent4(g.GenerateEncodeField(packet, f)))))
			b.WriteString(AddIndent4ln(AddIndent4("}")))
			b.WriteString(AddIndent4ln("}"))
		} else {
			b.WriteString(AddIndent4ln(g.GenerateEncodeField(packet, f)))
		}
	}
	b.WriteString("}\n")
	return b.String()
}

// GenerateEncodeField gen encode field
func (g JavaGenerator) GenerateEncodeField(p *model.Packet, f *model.Field) string {
	fieldNameLowerCamel := strcase.ToLowerCamel(f.Name)
	if _, ok := f.LenAttr.(*model.LengthFieldAttribute); ok {
		var b strings.Builder
		b.WriteString(fmt.Sprintf("int %sStart = byteBuf.writerIndex();", fieldNameLowerCamel))
		b.WriteString(fmt.Sprintf("if (this.%s != null) {\n", fieldNameLowerCamel))
		b.WriteString(fmt.Sprintf("    this.%s.encode(byteBuf);\n", fieldNameLowerCamel))
		b.WriteString("}\n")
		lenTyp := javaBasicTypeMap[p.LengthField.GetType()]
		b.WriteString(fmt.Sprintf("int %sEnd = byteBuf.writerIndex();", fieldNameLowerCamel))
		lengthFieldName := strcase.ToLowerCamel(p.LengthField.Name)
		b.WriteString(fmt.Sprintf("this.%s = (%s)(%sEnd - %sStart);", lengthFieldName, lenTyp.BasicType, fieldNameLowerCamel, fieldNameLowerCamel))
		if g.GetConfig().LittleEndian {
			b.WriteString(fmt.Sprintf("byteBuf.set%s(%sPos, this.%s);", lenTyp.Le, lengthFieldName, lengthFieldName))
		} else {
			b.WriteString(fmt.Sprintf("byteBuf.set%s(%sPos, this.%s);", strcase.ToCamel(lenTyp.BasicType), lengthFieldName, lengthFieldName))
		}
		return b.String()
	}
	if f.IsRepeat {
		fieldNameLowerCamel += ".get(i)"
	}
	switch c := f.Attr.(type) {
	case *model.DynamicStringFieldAttribute:
		var b strings.Builder
		lenTyp := javaBasicTypeMap[g.GetConfig().StringLenPrefixLenType]

		b.WriteString(fmt.Sprintf("if (StringUtil.isNullOrEmpty(this.%s)) {\n", fieldNameLowerCamel))
		b.WriteString(AddIndent4ln(fmt.Sprintf("byteBuf.write%s(0);", strcase.ToCamel(lenTyp.BasicType))))
		b.WriteString("} else {\n")
		b.WriteString(AddIndent4ln(fmt.Sprintf("byte[] bytes = this.%s.getBytes(StandardCharsets.UTF_8);", fieldNameLowerCamel)))
		if g.GetConfig().LittleEndian {
			b.WriteString(AddIndent4ln(fmt.Sprintf("byteBuf.write%s(bytes.length);", lenTyp.Le)))
		} else {
			b.WriteString(AddIndent4ln(fmt.Sprintf("byteBuf.write%s(bytes.length);", strcase.ToCamel(lenTyp.BasicType))))
		}
		b.WriteString(AddIndent4ln("byteBuf.writeBytes(bytes);"))
		b.WriteString("}\n")
		return b.String()
	case *model.FixedStringFieldAttribute:
		padding := g.GetPadding(f)
		if !padding.IsDefault() {
			return fmt.Sprintf("writeFixedString(byteBuf, this.%s, %d, %s, %t);", fieldNameLowerCamel, c.Length, padding.PadChar, padding.PadLeft)
		}
		return fmt.Sprintf("writeFixedString(byteBuf, this.%s, %d);", fieldNameLowerCamel, c.Length)
	case *model.LengthFieldAttribute:
		// auto calculate length field
		var b strings.Builder
		lenTyp := javaBasicTypeMap[f.GetType()]
		b.WriteString(fmt.Sprintf("int %sPos = byteBuf.writerIndex();\n", fieldNameLowerCamel))
		if g.GetConfig().LittleEndian {
			b.WriteString(fmt.Sprintf("byteBuf.write%s(0);\n", lenTyp.Le))
		} else {
			b.WriteString(fmt.Sprintf("byteBuf.write%s(0);\n", strcase.ToCamel(lenTyp.BasicType)))
		}

		return b.String()
	case *model.CheckSumFieldAttribute:
		// auto calculate checksum
		var b strings.Builder
		b.WriteString(fmt.Sprintf("ChecksumService<ByteBuf, Integer> checksumService = ChecksumServiceFactory.getInstance().getChecksumService(%s);\n", c.CheckSumType))
		b.WriteString("if (checksumService != null) {\n")
		lenTyp := javaBasicTypeMap[f.GetType()]
		b.WriteString(fmt.Sprintf("this.%s = (%s) checksumService.calc(byteBuf);\n", fieldNameLowerCamel, lenTyp.BasicType))
		b.WriteString("}\n")
		if g.GetConfig().LittleEndian {
			b.WriteString(fmt.Sprintf("byteBuf.write%s(this.%s);\n", lenTyp.Le, fieldNameLowerCamel))
		} else {
			b.WriteString(fmt.Sprintf("byteBuf.write%s(this.%s);\n", strcase.ToCamel(lenTyp.BasicType), fieldNameLowerCamel))
		}
		return b.String()
	case *model.BasicFieldAttribute:
		typ := javaBasicTypeMap[f.GetType()]
		if g.GetConfig().LittleEndian {
			return fmt.Sprintf("byteBuf.write%s(this.%s);", typ.Le, fieldNameLowerCamel)
		}
		return fmt.Sprintf("byteBuf.write%s(this.%s);", strcase.ToCamel(typ.BasicType), fieldNameLowerCamel)
	case *model.ObjectFieldAttribute:
		if c.IsIner {
			var b strings.Builder
			fieldNameLowerCamel = strcase.ToLowerCamel(c.RefPacket.Name)
			if f.IsRepeat {
				fieldNameLowerCamel += ".get(i)"
			}
			b.WriteString(fmt.Sprintf("this.%s.encode(byteBuf);", fieldNameLowerCamel))
			return b.String()
		}
		var b strings.Builder
		b.WriteString(fmt.Sprintf("this.%s.encode(byteBuf);", fieldNameLowerCamel))
		return b.String()

	case *model.MatchFieldAttribute:
		var b strings.Builder
		b.WriteString(fmt.Sprintf("if (null != this.%s) {\n", fieldNameLowerCamel))
		b.WriteString(fmt.Sprintf("this.%s.encode(byteBuf);", fieldNameLowerCamel))
		b.WriteString("}")
		return b.String()
	default:
		return "// unknow type"
	}
}

// GenerateJavaTestClassFileForPacket gen test class
func (g JavaGenerator) GenerateJavaTestClassFileForPacket(packet *model.Packet) string {
	var b strings.Builder
	//package
	b.WriteString(fmt.Sprintf("package %s;\n", g.GetConfig().JavaPackage))
	//import
	b.WriteString(`import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import org.junit.Test;

import java.util.Arrays;

import static org.junit.Assert.*;
`)
	b.WriteString("\n")
	b.WriteString("\n")

	b.WriteString(fmt.Sprintf("public class %sTest {\n", packet.Name))

	b.WriteString(AddIndent4ln(g.GenerateTestMethod(packet)))
	b.WriteString("}\n")

	return b.String()
}

// GenerateTestMethod gen test method
func (g JavaGenerator) GenerateTestMethod(packet *model.Packet) string {
	var b strings.Builder
	b.WriteString("@Test\n")
	b.WriteString("public void testEncodeDecode() {\n")
	b.WriteString(AddIndent4ln(g.GenerateNewInstance("original", "", packet)))
	b.WriteString(AddIndent4ln("ByteBuf buffer = Unpooled.buffer();"))
	b.WriteString(AddIndent4ln("original.encode(buffer);"))
	b.WriteString(AddIndent4ln(fmt.Sprintf("%s decoded = new %s();", packet.Name, packet.Name)))
	b.WriteString(AddIndent4ln("decoded.decode(buffer);"))
	b.WriteString(AddIndent4ln("assertEquals(original, decoded);"))
	b.WriteString("}")
	return b.String()
}

// GenerateNewInstance new instance for unitest
func (g JavaGenerator) GenerateNewInstance(instanceName string, parent string, packet *model.Packet) string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("%s%s %s = new %s%s();\n", parent, packet.Name, instanceName, parent, packet.Name))
	for _, f := range packet.Fields {
		fieldNameCamel := strcase.ToCamel(f.Name)
		if _, ok := packet.MatchFields[f.Name]; ok {
			continue
		}
		switch c := f.Attr.(type) {
		case *model.BasicFieldAttribute, *model.CheckSumFieldAttribute:
			if typ, ok := javaBasicTypeMap[f.GetType()]; ok {
				if f.IsRepeat {
					b.WriteString(fmt.Sprintf("%s.set%s(Arrays.asList(%s));\n", instanceName, fieldNameCamel, typ.TestValue))
				} else {
					b.WriteString(fmt.Sprintf("%s.set%s(%s);\n", instanceName, fieldNameCamel, typ.TestValue))
				}
			}
		case *model.FixedStringFieldAttribute:
			if f.IsRepeat {
				b.WriteString(fmt.Sprintf("%s.set%s(Arrays.asList(\"%s\"));\n", instanceName, fieldNameCamel, strings.Repeat("1", c.Length)))
			} else {
				b.WriteString(fmt.Sprintf("%s.set%s(\"%s\");\n", instanceName, fieldNameCamel, strings.Repeat("1", c.Length)))
			}
		case *model.DynamicStringFieldAttribute:
			if f.IsRepeat {
				b.WriteString(fmt.Sprintf("%s.set%s(Arrays.asList(\"example\"));\n", instanceName, fieldNameCamel))
			} else {
				b.WriteString(fmt.Sprintf("%s.set%s(\"example\");\n", instanceName, fieldNameCamel))
			}
		case *model.ObjectFieldAttribute:
			inerObjName := strcase.ToLowerCamel(f.Name) + "0"
			parent := ""
			if c.IsIner {
				inerObjName = strcase.ToLowerCamel(c.RefPacket.Name)
				parent = packet.Name + "."
			}
			b.WriteString(g.GenerateNewInstance(inerObjName, parent, c.RefPacket))
			if f.IsRepeat {
				b.WriteString(fmt.Sprintf("%s.set%s(Arrays.asList(%s));\n", instanceName, fieldNameCamel, inerObjName))
			} else {
				b.WriteString(fmt.Sprintf("%s.set%s(%s);\n", instanceName, fieldNameCamel, inerObjName))
			}
		case *model.MatchFieldAttribute:
			//
			key := c.MatchPairs[0].Key
			value := c.MatchPairs[0].Value
			if typ, ok := javaBasicTypeMap[packet.FieldMap[c.MatchKeyField.Name].GetType()]; ok {
				key = fmt.Sprintf("(%s)%s", typ.BasicType, key)
			}
			b.WriteString(fmt.Sprintf("%s.set%s(%s);\n", instanceName, strcase.ToCamel(c.MatchKeyField.Name), key))
			if p, ok := g.binModel.PacketsMap[value]; ok {
				inerObjName := strcase.ToLowerCamel(p.Name)
				b.WriteString(g.GenerateNewInstance(inerObjName, "", p))
				b.WriteString(fmt.Sprintf("%s.set%s(%s);\n", instanceName, fieldNameCamel, inerObjName))
			}
		}
	}
	return b.String()
}
