package parser

import (
	"fmt"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/xinchentechnote/fin-protoc/internal/model"
)

// LuaType lua basic type
type LuaType struct {
	Name string
	To   string
	Size uint32
}

// luaBasicTypeMap dsl basic type to lua type
var luaBasicTypeMap = map[string]LuaType{
	// 无符号整数类型
	"u8": {
		Name: "u8",
		To:   "uint32",
		Size: 1,
	},
	"char": {
		Name: "char",
		To:   "char",
		Size: 1,
	},
	"u16": {
		Name: "u16",
		To:   "uint32",
		Size: 2,
	},
	"u24": {
		Name: "u24",
		To:   "uint32",
		Size: 3,
	},
	"u32": {
		Name: "u32",
		To:   "uint32",
		Size: 4,
	},
	"u64": {
		Name: "u64",
		To:   "uint64",
		Size: 8,
	},

	// 有符号整数类型
	"i8": {
		Name: "i8",
		To:   "int",
		Size: 1,
	},
	"i16": {
		Name: "i16",
		To:   "int",
		Size: 2,
	},
	"i24": {
		Name: "i24",
		To:   "int",
		Size: 3,
	},
	"i32": {
		Name: "i32",
		To:   "int",
		Size: 4,
	},
	"i64": {
		Name: "i64",
		To:   "int64",
		Size: 8,
	},

	// 浮点类型
	"f32": {
		Name: "f32",
		To:   "float",
		Size: 4,
	},
	"f64": {
		Name: "f64",
		To:   "double",
		Size: 8,
	},
}

// lua base wireshark plugin generator

// LuaWspGenerator implements Generator for lua bases wireshark plugin
type LuaWspGenerator struct {
	config *GeneratorConfig
}

// NewLuaWspGenerator new
func NewLuaWspGenerator(config *GeneratorConfig) *LuaWspGenerator {
	return &LuaWspGenerator{
		config: config,
	}
}

// Generate code
func (g LuaWspGenerator) Generate(binModel *model.BinaryModel) (map[string][]byte, error) {
	output := make(map[string][]byte)
	var b strings.Builder
	b.WriteString("-- Code generated by fin-protoc. DO NOT EDIT.\n")
	b.WriteString("\n")
	b.WriteString(`local function parse_be_uint64(buf, offset)
    local bytes = buf(offset, 8):bytes()
    return bytes:get_index(0) * 0x100000000000000 +
        bytes:get_index(1) * 0x1000000000000 +
        bytes:get_index(2) * 0x10000000000 +
        bytes:get_index(3) * 0x100000000 +
        bytes:get_index(4) * 0x1000000 +
        bytes:get_index(5) * 0x10000 +
        bytes:get_index(6) * 0x100 +
        bytes:get_index(7)
end`)
	b.WriteString("\n")
	b.WriteString("\n")
	rootPacket := binModel.RootPacket
	//Proto
	b.WriteString(fmt.Sprintf("local %s_proto = Proto(\"%s\", \"%s Protocol\")\n", strcase.ToSnake(rootPacket.Name), rootPacket.Name, rootPacket.Name))
	//ProtoField
	b.WriteString(g.generateFieldDefinition(binModel))
	b.WriteString(fmt.Sprintf(`for _, field in pairs(fields) do
    %s_proto.fields[field] = field
end`, strcase.ToSnake(rootPacket.Name)))
	b.WriteString("\n\n")
	//Sub Dissector
	for _, pkt := range binModel.Packets {
		if !pkt.IsRoot {
			b.WriteString(g.generateSubDissector(rootPacket.Name, pkt))
			b.WriteString("\n\n")
		}
	}
	//Main Dissector
	b.WriteString(g.generateMainDissector(rootPacket))
	b.WriteString("\n\n")

	//registry port
	b.WriteString("local tcp_table = DissectorTable.get(\"tcp.port\")\n")
	b.WriteString(fmt.Sprintf("tcp_table:add(%d, %s_proto)\n", 8080, strcase.ToSnake(rootPacket.Name)))
	output[strcase.ToSnake(strcase.ToSnake(rootPacket.Name))+".lua"] = []byte(b.String())
	return output, nil
}

func (g LuaWspGenerator) generateSubDissector(parentName string, pkt model.Packet) string {
	var b strings.Builder

	for _, f := range pkt.Fields {
		if f.InerObject != nil {
			b.WriteString(g.generateSubDissector(parentName, *f.InerObject))
			b.WriteString("\n")
		}
	}

	b.WriteString(fmt.Sprintf("local function dissect_%s(buf, pinfo, tree, offset)\n", strcase.ToSnake(pkt.Name)))
	b.WriteString(fmt.Sprintf("    local subtree = tree:add(%s_proto, buf(offset, 1), \"%s\")\n", strcase.ToSnake(parentName), pkt.Name))
	if len(pkt.Fields) > 0 {
		for _, f := range pkt.Fields {
			if isMatchField(f, pkt) && f.GetType() != "match" {
				b.WriteString(fmt.Sprintf("    local %s = buf(offset, %s):uint()\n", strcase.ToSnake(f.Name), "4"))
			}
			if f.IsRepeat {
				b.WriteString(g.decodeListSize("subtree", pkt, f))
				b.WriteString(fmt.Sprintf("    for i=1,%s_%s_%s do\n", strcase.ToSnake(pkt.Name), strcase.ToSnake(f.Name), "size"))
				b.WriteString("        offset = " + g.decodeField("subtree", pkt, f) + "\n")
				b.WriteString(fmt.Sprintf("        pinfo.cols.info:append(\" %s[\"..i..\"]\")\n", f.Name))
				b.WriteString("    end\n")
			} else {
				b.WriteString(g.decodeField("subtree", pkt, f))
			}
		}
	} else {
		b.WriteString("    subtree:append_text(\" (No Body)\")\n")
	}
	b.WriteString("    return offset\n")
	b.WriteString("end\n")
	return b.String()
}

func (g LuaWspGenerator) generateMainDissector(rootPacket model.Packet) string {
	var b strings.Builder

	for _, f := range rootPacket.Fields {
		if f.InerObject != nil {
			b.WriteString(g.generateSubDissector(rootPacket.Name, *f.InerObject))
			b.WriteString("\n")
		}
	}

	b.WriteString(fmt.Sprintf("function %s_proto.dissector(buf, pinfo, tree)\n", strcase.ToSnake(rootPacket.Name)))
	b.WriteString(fmt.Sprintf("    pinfo.cols.protocol = \"%s\"\n", strcase.ToSnake(rootPacket.Name)))
	b.WriteString("    local offset = 0\n")
	for _, f := range rootPacket.Fields {
		if isMatchField(f, rootPacket) && f.GetType() != "match" {
			b.WriteString(fmt.Sprintf("    local %s = buf(offset, %s):uint()\n", strcase.ToSnake(f.Name), "4"))
		}
		if f.IsRepeat {
			b.WriteString(g.decodeListSize("tree", rootPacket, f))
			b.WriteString(fmt.Sprintf("    for i=1,%s_%s_%s do\n", strcase.ToSnake(rootPacket.Name), strcase.ToSnake(f.Name), "size"))
			b.WriteString("        offset = " + g.decodeField("tree", rootPacket, f))
			b.WriteString(fmt.Sprintf("        pinfo.cols.info:append(\" %s[\"..i..\"]\")\n", f.Name))
			b.WriteString("    end\n")
		} else {
			b.WriteString(g.decodeField("tree", rootPacket, f))
		}
	}
	b.WriteString("end\n")
	return b.String()
}

func isMatchField(f model.Field, rootPacket model.Packet) bool {
	for _, field := range rootPacket.Fields {
		if field.GetType() == "match" && f.Name == field.MatchType {
			return true
		}
	}
	return false
}

// local {{.Name}} = buf(offset, {{.Type.Size}}):uint()
const decodeFieldTmpl = `    {{.TreeName}}:add(fields.{{.Name}}, buf(offset, {{.Type.Size}}))
    offset = offset + {{.Type.Size}}`

func (g LuaWspGenerator) decodeListSize(treeName string, p model.Packet, f model.Field) string {
	var prefix = g.config.ListLenPrefixLenType
	switch prefix {
	case "i8", "u8", "i16", "u16", "i32", "u32", "i64", "u64":
		luaType := luaBasicTypeMap[prefix]
		// data := map[string]interface{}{
		// 	"Name":     fmt.Sprintf("%s_%s_%s", strcase.ToSnake(p.Name), strcase.ToSnake(f.Name), "size"),
		// 	"TreeName": treeName,
		// 	"Type":     luaType,
		// }
		// code, err := RenderToString(decodeFieldTmpl, "lua", data)
		// if err != nil {
		// 	return "-- error generating code: " + err.Error() + "\n"
		// }
		code := fmt.Sprintf("    local %s_%s_%s = buf(offset, %d):uint()\n", strcase.ToSnake(p.Name), strcase.ToSnake(f.Name), "size", luaType.Size)
		code += fmt.Sprintf("    %s:add(\"%s Size: \".. %s_%s_%s, buf(offset, %d))\n", treeName, f.Name, strcase.ToSnake(p.Name), strcase.ToSnake(f.Name), "size", luaType.Size)
		code += fmt.Sprintf("    offset = offset + %d\n", luaType.Size)
		return code + "\n"
	default:
		return "-- unsupported numeric type: " + f.GetType() + "\n"
	}
}

func (g LuaWspGenerator) decodeField(treeName string, p model.Packet, f model.Field) string {
	switch f.GetType() {
	case "i8", "u8", "i16", "u16", "i32", "u32", "i64", "u64", "f32", "f64", "char":
		luaType, ok := luaBasicTypeMap[f.GetType()]
		if !ok {
			return "-- unsupported numeric type: " + f.GetType() + "\n"
		}
		data := map[string]interface{}{
			"Name":     fmt.Sprintf("%s_%s", strcase.ToSnake(p.Name), strcase.ToSnake(f.Name)),
			"TreeName": treeName,
			"Type":     luaType,
		}
		code, err := RenderToString(decodeFieldTmpl, "lua", data)
		if err != nil {
			return "-- error generating code: " + err.Error() + "\n"
		}
		return code + "\n"
	case "match":
		if len(f.MatchPairs) == 0 {
			return ""
		}
		var b strings.Builder
		b.WriteString("    ")
		for i, pair := range f.MatchPairs {
			if i != 0 {
				b.WriteString("else")
			}
			b.WriteString(fmt.Sprintf("if %s == %s then -- %s\n", strcase.ToSnake(f.MatchType), pair.Key, pair.Value))
			b.WriteString(fmt.Sprintf("        dissect_%s(buf, pinfo, tree, offset)\n", strcase.ToSnake(pair.Value)))
			b.WriteString(fmt.Sprintf("        pinfo.cols.info:set(\"%s\")\n", pair.Value))
		}
		b.WriteString("    end\n")
		return b.String()

	default:
		var b strings.Builder
		if size, ok := ParseCharArrayType(f.GetType()); ok {
			b.WriteString(fmt.Sprintf("    %s:add(fields.%s_%s, buf(offset, %s))\n", treeName, strcase.ToSnake(p.Name), strcase.ToSnake(f.Name), size))
			b.WriteString(fmt.Sprintf("    offset = offset + %s\n", size))
			return b.String()
		} else if f.InerObject != nil {
			b.WriteString(fmt.Sprintf("    dissect_%s(buf, pinfo, subtree, offset)\n", strcase.ToSnake(f.Name)))
			if !f.IsRepeat {
				b.WriteString(fmt.Sprintf("    pinfo.cols.info:set(\"%s\")\n", f.Name))
			}
			return b.String()
		}
		return "-- unsupported type: " + f.GetType() + "\n"
	}
}

func (g LuaWspGenerator) generateFieldDefinition(model *model.BinaryModel) string {
	var b strings.Builder
	b.WriteString("local fields = {\n")
	for _, pkt := range model.Packets {
		b.WriteString(g.generateFieldDefinitionFromPacket(model, &pkt))
	}
	b.WriteString("}\n\n")

	return b.String()
}

func (g LuaWspGenerator) generateFieldDefinitionFromPacket(mdl *model.BinaryModel, pkt *model.Packet) string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("    -- Field from %s\n", pkt.Name))
	for _, f := range pkt.Fields {
		switch f.GetType() {
		case "char":
			b.WriteString(fmt.Sprintf("    %s_%s = ProtoField.char(\"%s.%s\", \"%s\", base.OCT),\n",
				strcase.ToSnake(pkt.Name), strcase.ToSnake(f.Name), strcase.ToSnake(pkt.Name), strcase.ToSnake(f.Name), f.Name))
		case "i8", "u8", "i16", "u16", "i32", "u32", "i64", "u64", "f32", "f64":
			luaType, ok := luaBasicTypeMap[f.GetType()]
			if !ok {
				b.WriteString("-- unsupported numeric type: " + f.GetType() + "\n")
			} else {
				b.WriteString(fmt.Sprintf("    %s_%s = ProtoField.%s(\"%s.%s\", \"%s\", base.DEC),\n",
					strcase.ToSnake(pkt.Name), strcase.ToSnake(f.Name), luaType.To, strcase.ToSnake(pkt.Name), strcase.ToSnake(f.Name), f.Name))
			}
		case "string", "char[]":
			b.WriteString(fmt.Sprintf("    %s_%s = ProtoField.string(\"%s.%s\", \"%s\"),\n",
				strcase.ToSnake(pkt.Name), strcase.ToSnake(f.Name), strcase.ToSnake(pkt.Name), strcase.ToSnake(f.Name), f.Name))
		case "bytes":
			b.WriteString(fmt.Sprintf("    %s_%s = ProtoField.bytes(\"%s.%s\", \"%s\"),\n",
				strcase.ToSnake(pkt.Name), strcase.ToSnake(f.Name), strcase.ToSnake(pkt.Name), strcase.ToSnake(f.Name), f.Name))
		case "bool":
			b.WriteString(fmt.Sprintf("    %s_%s = ProtoField.bool(\"%s.%s\", \"%s\"),\n",
				strcase.ToSnake(pkt.Name), strcase.ToSnake(f.Name), strcase.ToSnake(pkt.Name), strcase.ToSnake(f.Name), f.Name))
		default:
			_, ok := ParseCharArrayType(f.GetType())
			if ok {
				b.WriteString(fmt.Sprintf("    %s_%s = ProtoField.string(\"%s.%s\", \"%s\"),\n",
					strcase.ToSnake(pkt.Name), strcase.ToSnake(f.Name), strcase.ToSnake(pkt.Name), strcase.ToSnake(f.Name), f.Name))
			} else if p, ok := mdl.PacketsMap[f.Name]; ok {
				b.WriteString(g.generateFieldDefinitionFromPacket(mdl, &p))
			} else if f.InerObject != nil {
				b.WriteString(g.generateFieldDefinitionFromPacket(mdl, f.InerObject))
			} else {
				b.WriteString(fmt.Sprintf("    -- Unsupported type: %s\n", f.GetType()))
			}
		}
	}
	return b.String()
}
