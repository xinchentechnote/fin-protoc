package parser

import (
	"fmt"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/xinchentechnote/fin-protoc/internal/model"
)

// LuaType lua basic type
type LuaType struct {
	Name string
	To   string
	Size uint32
}

// luaBasicTypeMap dsl basic type to lua type
var luaBasicTypeMap = map[string]LuaType{
	// 无符号整数类型
	"u8": {
		Name: "u8",
		To:   "uint32",
		Size: 1,
	},
	"char": {
		Name: "char",
		To:   "char",
		Size: 1,
	},
	"u16": {
		Name: "u16",
		To:   "uint32",
		Size: 2,
	},
	"u24": {
		Name: "u24",
		To:   "uint32",
		Size: 3,
	},
	"u32": {
		Name: "u32",
		To:   "uint32",
		Size: 4,
	},
	"u64": {
		Name: "u64",
		To:   "uint64",
		Size: 8,
	},

	// 有符号整数类型
	"i8": {
		Name: "i8",
		To:   "int",
		Size: 1,
	},
	"i16": {
		Name: "i16",
		To:   "int",
		Size: 2,
	},
	"i24": {
		Name: "i24",
		To:   "int",
		Size: 3,
	},
	"i32": {
		Name: "i32",
		To:   "int",
		Size: 4,
	},
	"i64": {
		Name: "i64",
		To:   "int64",
		Size: 8,
	},

	// 浮点类型
	"f32": {
		Name: "f32",
		To:   "float",
		Size: 4,
	},
	"f64": {
		Name: "f64",
		To:   "double",
		Size: 8,
	},
}

// lua base wireshark plugin generator

// LuaWspGenerator implements Generator for lua bases wireshark plugin
type LuaWspGenerator struct {
	config   *GeneratorConfig
	binModel *model.BinaryModel
}

// NewLuaWspGenerator new
func NewLuaWspGenerator(config *GeneratorConfig, binModel *model.BinaryModel) *LuaWspGenerator {
	return &LuaWspGenerator{
		config:   config,
		binModel: binModel,
	}
}

// Generate code
func (g LuaWspGenerator) Generate(binModel *model.BinaryModel) (map[string][]byte, error) {
	output := make(map[string][]byte)
	var b strings.Builder
	b.WriteString("-- Code generated by fin-protoc. DO NOT EDIT.\n")
	b.WriteString("\n")
	b.WriteString(`local function parse_be_uint64(buf, offset)
    local bytes = buf(offset, 8):bytes()
    return bytes:get_index(0) * 0x100000000000000 +
        bytes:get_index(1) * 0x1000000000000 +
        bytes:get_index(2) * 0x10000000000 +
        bytes:get_index(3) * 0x100000000 +
        bytes:get_index(4) * 0x1000000 +
        bytes:get_index(5) * 0x10000 +
        bytes:get_index(6) * 0x100 +
        bytes:get_index(7)
end`)
	b.WriteString("\n")
	b.WriteString("\n")
	rootPacket := binModel.RootPacket
	//Proto
	b.WriteString(fmt.Sprintf("local %s_proto = Proto(\"%s\", \"%s Protocol\")\n", strcase.ToSnake(rootPacket.Name), rootPacket.Name, rootPacket.Name))
	//ProtoField
	b.WriteString(g.generateFieldDefinition(binModel))
	b.WriteString(fmt.Sprintf(`for _, field in pairs(fields) do
    %s_proto.fields[field] = field
end`, strcase.ToSnake(rootPacket.Name)))
	b.WriteString("\n\n")
	//Sub Dissector
	for _, pkt := range binModel.Packets {
		if !pkt.IsRoot {
			b.WriteString(g.generateSubDissector(rootPacket.Name, pkt))
			b.WriteString("\n\n")
		}
	}
	//Main Dissector
	b.WriteString(g.generateMainDissector(rootPacket))
	b.WriteString("\n\n")

	//registry port
	b.WriteString("local tcp_table = DissectorTable.get(\"tcp.port\")\n")
	b.WriteString(fmt.Sprintf("tcp_table:add(%d, %s_proto)\n", 8080, strcase.ToSnake(rootPacket.Name)))
	output[strcase.ToSnake(rootPacket.Name)+".lua"] = []byte(b.String())
	return output, nil
}

func (g LuaWspGenerator) generateSubDissector(parentName string, pkt model.Packet) string {
	var b strings.Builder

	for _, f := range pkt.Fields {
		if f.InerObject != nil {
			b.WriteString(g.generateSubDissector(parentName, *f.InerObject))
			b.WriteString("\n")
		}
	}

	b.WriteString(fmt.Sprintf("local function dissect_%s(buf, pinfo, tree, offset)\n", strcase.ToSnake(pkt.Name)))
	b.WriteString(AndIndent4ln(fmt.Sprintf("local subtree = tree:add(%s_proto, buf(offset, 1), \"%s\")", strcase.ToSnake(parentName), pkt.Name)))
	if len(pkt.Fields) > 0 {
		for _, f := range pkt.Fields {
			if isMatchField(f, pkt) && f.GetType() != "match" {
				b.WriteString(AndIndent4ln(fmt.Sprintf("local %s = buf(offset, %s):uint()", strcase.ToSnake(f.Name), "4")))
			}
			if f.IsRepeat {
				b.WriteString(AndIndent4ln(g.decodeList("subtree", pkt, f)))
			} else {
				b.WriteString(AndIndent4ln(g.decodeField("subtree", pkt, f)))
			}
		}
	} else {
		b.WriteString(AndIndent4ln("subtree:append_text(\" (No Body)\")"))
	}
	b.WriteString(AndIndent4ln("return offset"))
	b.WriteString("end\n")
	return b.String()
}

func (g LuaWspGenerator) generateMainDissector(rootPacket model.Packet) string {
	var b strings.Builder

	for _, f := range rootPacket.Fields {
		if f.InerObject != nil {
			b.WriteString(g.generateSubDissector(rootPacket.Name, *f.InerObject))
			b.WriteString("\n")
		}
	}

	b.WriteString(fmt.Sprintf("function %s_proto.dissector(buf, pinfo, tree)\n", strcase.ToSnake(rootPacket.Name)))
	b.WriteString(AndIndent4ln(fmt.Sprintf("pinfo.cols.protocol = \"%s\"", strcase.ToSnake(rootPacket.Name))))
	b.WriteString(AndIndent4ln("local offset = 0"))
	for _, f := range rootPacket.Fields {
		if isMatchField(f, rootPacket) && f.GetType() != "match" {
			b.WriteString(AndIndent4ln(fmt.Sprintf("local %s = buf(offset, %s):uint()", strcase.ToSnake(f.Name), "4")))
		}
		if f.IsRepeat {
			b.WriteString(AndIndent4ln(g.decodeList("tree", rootPacket, f)))
		} else {
			b.WriteString(AndIndent4ln(g.decodeField("tree", rootPacket, f)))
		}
	}
	b.WriteString("end\n")
	return b.String()
}

func (g LuaWspGenerator) decodeList(treeName string, p model.Packet, f model.Field) string {
	var b strings.Builder
	b.WriteString(g.decodeListSize(treeName, p, f) + "\n")
	b.WriteString(fmt.Sprintf("for i=1,%s_%s_%s do\n", strcase.ToSnake(p.Name), strcase.ToSnake(f.Name), "size"))
	code := g.decodeField(treeName, p, f)
	if f.InerObject != nil {
		code = "offset = " + code
	}
	b.WriteString(AndIndent4ln(code))
	b.WriteString(AndIndent4ln(fmt.Sprintf("pinfo.cols.info:append(\" %s[\"..i..\"]\")", f.Name)))
	b.WriteString("end")
	return b.String()
}

func isMatchField(f model.Field, rootPacket model.Packet) bool {
	for _, field := range rootPacket.Fields {
		if field.GetType() == "match" && f.Name == field.MatchType {
			return true
		}
	}
	return false
}

// local {{.Name}} = buf(offset, {{.Type.Size}}):uint()
const decodeFieldTmpl = `{{.TreeName}}:add(fields.{{.Name}}, buf(offset, {{.Type.Size}}))
offset = offset + {{.Type.Size}}`

func (g LuaWspGenerator) decodeListSize(treeName string, p model.Packet, f model.Field) string {
	var prefix = g.config.ListLenPrefixLenType
	switch prefix {
	case "i8", "u8", "i16", "u16", "i32", "u32", "i64", "u64":
		luaType := luaBasicTypeMap[prefix]
		sizeName := fmt.Sprintf("%s_%s_%s", strcase.ToSnake(p.Name), strcase.ToSnake(f.Name), "size")
		code := fmt.Sprintf("local %s = buf(offset, %d):uint()\n", sizeName, luaType.Size)
		code += fmt.Sprintf("%s:add(\"%s Size: \".. %s, buf(offset, %d))\n", treeName, f.Name, sizeName, luaType.Size)
		code += fmt.Sprintf("offset = offset + %d", luaType.Size)
		return code
	default:
		return "-- unsupported numeric type: " + f.GetType() + "\n"
	}
}

func (g LuaWspGenerator) decodeStringLen(treeName string, p model.Packet, f model.Field) string {
	var prefix = g.config.StringLenPrefixLenType
	switch prefix {
	case "i8", "u8", "i16", "u16", "i32", "u32", "i64", "u64":
		luaType := luaBasicTypeMap[prefix]
		lenName := fmt.Sprintf("%s_%s_%s", strcase.ToSnake(p.Name), strcase.ToSnake(f.Name), "len")
		code := fmt.Sprintf("local %s = buf(offset, %d):uint()\n", lenName, luaType.Size)
		code += fmt.Sprintf("%s:add(\"%s Len: \".. %s, buf(offset, %d))\n", treeName, f.Name, lenName, luaType.Size)
		code += fmt.Sprintf("offset = offset + %d", luaType.Size)
		return code
	default:
		return "-- unsupported numeric type: " + f.GetType()
	}
}

func (g LuaWspGenerator) decodeField(treeName string, p model.Packet, f model.Field) string {
	switch f.GetType() {
	case "i8", "u8", "i16", "u16", "i32", "u32", "i64", "u64", "f32", "f64", "char":
		luaType, ok := luaBasicTypeMap[f.GetType()]
		if !ok {
			return "-- unsupported numeric type: " + f.GetType() + "\n"
		}
		data := map[string]interface{}{
			"Name":     fmt.Sprintf("%s_%s", strcase.ToSnake(p.Name), strcase.ToSnake(f.Name)),
			"TreeName": treeName,
			"Type":     luaType,
		}
		code, err := RenderToString(decodeFieldTmpl, "lua", data)
		if err != nil {
			return "-- error generating code: " + err.Error() + "\n"
		}
		return code
	case "match":
		if len(f.MatchPairs) == 0 {
			return ""
		}
		var b strings.Builder
		for i, pair := range f.MatchPairs {
			if i != 0 {
				b.WriteString("else")
			}
			b.WriteString(fmt.Sprintf("if %s == %s then -- %s\n", strcase.ToSnake(f.MatchType), pair.Key, pair.Value))
			b.WriteString(AndIndent4ln(fmt.Sprintf("dissect_%s(buf, pinfo, tree, offset)", strcase.ToSnake(pair.Value))))
			b.WriteString(AndIndent4ln(fmt.Sprintf("pinfo.cols.info:set(\"%s\")", pair.Value)))
		}
		b.WriteString("end")
		return b.String()
	case "string":
		var b strings.Builder
		b.WriteString(g.decodeStringLen(treeName, p, f) + "\n")
		lenName := fmt.Sprintf("%s_%s_%s", strcase.ToSnake(p.Name), strcase.ToSnake(f.Name), "len")
		b.WriteString(fmt.Sprintf("%s:add(fields.%s_%s, buf(offset, %s))\n", treeName, strcase.ToSnake(p.Name), strcase.ToSnake(f.Name), lenName))
		b.WriteString(fmt.Sprintf("offset = offset + %s", lenName))
		return b.String()
	default:
		var b strings.Builder
		if size, ok := ParseCharArrayType(f.GetType()); ok {
			b.WriteString(fmt.Sprintf("%s:add(fields.%s_%s, buf(offset, %s))\n", treeName, strcase.ToSnake(p.Name), strcase.ToSnake(f.Name), size))
			b.WriteString(fmt.Sprintf("offset = offset + %s", size))
			return b.String()
		} else if f.InerObject != nil {
			b.WriteString(fmt.Sprintf("dissect_%s(buf, pinfo, subtree, offset)", strcase.ToSnake(f.Name)))
			if !f.IsRepeat {
				b.WriteString("\n")
				b.WriteString(fmt.Sprintf("pinfo.cols.info:set(\"%s\")", f.Name))
			}
			return b.String()
		}
		return "-- unsupported type: " + f.GetType() + "\n"
	}
}

func (g LuaWspGenerator) generateFieldDefinition(model *model.BinaryModel) string {
	var b strings.Builder
	b.WriteString("local fields = {\n")
	for _, pkt := range model.Packets {
		b.WriteString(g.generateFieldDefinitionFromPacket(model, &pkt))
	}
	b.WriteString("}\n\n")

	return b.String()
}

func (g LuaWspGenerator) generateFieldDefinitionFromPacket(mdl *model.BinaryModel, pkt *model.Packet) string {
	var b strings.Builder
	b.WriteString(AndIndent4ln(fmt.Sprintf("-- Field from %s", pkt.Name)))
	for _, f := range pkt.Fields {
		fieldName := strcase.ToSnake(pkt.Name) + "_" + strcase.ToSnake(f.Name)
		filterName := strcase.ToSnake(pkt.Name) + "." + strcase.ToSnake(f.Name)
		switch f.GetType() {
		case "char":
			b.WriteString(AndIndent4ln(fmt.Sprintf("%s = ProtoField.char(\"%s\", \"%s\", base.OCT),",
				fieldName, filterName, f.Name)))
		case "i8", "u8", "i16", "u16", "i32", "u32", "i64", "u64", "f32", "f64":
			luaType, ok := luaBasicTypeMap[f.GetType()]
			if !ok {
				b.WriteString("-- unsupported numeric type: " + f.GetType() + "\n")
			} else {
				b.WriteString(AndIndent4ln(fmt.Sprintf("%s = ProtoField.%s(\"%s\", \"%s\", base.DEC),",
					fieldName, luaType.To, filterName, f.Name)))
			}
		case "string", "char[]":
			b.WriteString(AndIndent4ln(fmt.Sprintf("%s = ProtoField.string(\"%s\", \"%s\"),",
				fieldName, filterName, f.Name)))
		case "bytes":
			b.WriteString(AndIndent4ln(fmt.Sprintf("%s = ProtoField.bytes(\"%s\", \"%s\"),",
				fieldName, filterName, f.Name)))
		case "bool":
			b.WriteString(AndIndent4ln(fmt.Sprintf("%s = ProtoField.bool(\"%s\", \"%s\"),",
				fieldName, filterName, f.Name)))
		default:
			_, ok := ParseCharArrayType(f.GetType())
			if ok {
				b.WriteString(AndIndent4ln(fmt.Sprintf("%s = ProtoField.string(\"%s\", \"%s\"),",
					fieldName, filterName, f.Name)))
			} else if p, ok := mdl.PacketsMap[f.Name]; ok {
				b.WriteString(g.generateFieldDefinitionFromPacket(mdl, &p))
			} else if f.InerObject != nil {
				b.WriteString(g.generateFieldDefinitionFromPacket(mdl, f.InerObject))
			} else {
				b.WriteString(AndIndent4ln(fmt.Sprintf("-- Unsupported type: %s", f.GetType())))
			}
		}
	}
	return b.String()
}
