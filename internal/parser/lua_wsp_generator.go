package parser

import (
	"fmt"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/xinchentechnote/fin-protoc/internal/model"
)

// LuaType lua basic type
type LuaType struct {
	Name    string
	LuaType string
	Be      string
	Le      string
	Size    uint32
}

// luaBasicTypeMap dsl basic type to lua type
var luaBasicTypeMap = map[string]LuaType{
	// 无符号整数类型
	"u8": {
		Name:    "u8",
		LuaType: "uint32",
		Be:      "uint",
		Le:      "le_uint",
		Size:    1,
	},
	"char": {
		Name:    "char",
		LuaType: "char",
		Be:      "uint",
		Le:      "le_uint",
		Size:    1,
	},
	"u16": {
		Name:    "u16",
		LuaType: "uint32",
		Be:      "uint",
		Le:      "le_uint",
		Size:    2,
	},
	"u24": {
		Name:    "u24",
		LuaType: "uint32",
		Be:      "uint",
		Le:      "le_uint",
		Size:    3,
	},
	"u32": {
		Name:    "u32",
		LuaType: "uint32",
		Be:      "uint",
		Le:      "le_uint",
		Size:    4,
	},
	"u64": {
		Name:    "u64",
		LuaType: "uint64",
		Be:      "uint64",
		Le:      "le_uint64",
		Size:    8,
	},

	// 有符号整数类型
	"i8": {
		Name:    "i8",
		LuaType: "int",
		Be:      "int",
		Le:      "le_int",
		Size:    1,
	},
	"i16": {
		Name:    "i16",
		LuaType: "int",
		Be:      "int",
		Le:      "le_int",
		Size:    2,
	},
	"i24": {
		Name:    "i24",
		LuaType: "int",
		Be:      "int",
		Le:      "le_int",
		Size:    3,
	},
	"i32": {
		Name:    "i32",
		LuaType: "int",
		Be:      "int",
		Le:      "le_int",
		Size:    4,
	},
	"i64": {
		Name:    "i64",
		LuaType: "int64",
		Be:      "int64",
		Le:      "le_int64",
		Size:    8,
	},

	// 浮点类型
	"f32": {
		Name:    "f32",
		LuaType: "float",
		Be:      "float",
		Le:      "le_float",
		Size:    4,
	},
	"f64": {
		Name:    "f64",
		LuaType: "double",
		Be:      "float",
		Le:      "le_float",
		Size:    8,
	},
}

// lua base wireshark plugin generator

// LuaWspGenerator implements Generator for lua bases wireshark plugin
type LuaWspGenerator struct {
	config   *GeneratorConfig
	binModel *model.BinaryModel
}

// NewLuaWspGenerator new
func NewLuaWspGenerator(config *GeneratorConfig, binModel *model.BinaryModel) *LuaWspGenerator {
	return &LuaWspGenerator{
		config:   config,
		binModel: binModel,
	}
}

// Generate code
func (g LuaWspGenerator) Generate(binModel *model.BinaryModel) (map[string][]byte, error) {
	output := make(map[string][]byte)
	var b strings.Builder
	b.WriteString("-- Code generated by fin-protoc. DO NOT EDIT.\n")
	b.WriteString("\n")
	b.WriteString("\n")
	rootPacket := binModel.RootPacket
	//Proto
	b.WriteString(fmt.Sprintf("local %s_proto = Proto(\"%s\", \"%s Protocol\")\n", strcase.ToSnake(rootPacket.Name), rootPacket.Name, rootPacket.Name))
	//ProtoField
	b.WriteString(g.generateFieldDefinition(binModel))
	b.WriteString(fmt.Sprintf(`for _, field in pairs(fields) do
    %s_proto.fields[field] = field
end`, strcase.ToSnake(rootPacket.Name)))
	b.WriteString("\n\n")
	//Sub Dissector
	for _, pkt := range binModel.Packets {
		if !pkt.IsRoot {
			b.WriteString(g.generateSubDissector(rootPacket.Name, pkt))
			b.WriteString("\n\n")
		}
	}
	//Main Dissector
	b.WriteString(g.generateMainDissector(rootPacket))
	b.WriteString("\n\n")

	//registry port
	b.WriteString("local tcp_table = DissectorTable.get(\"tcp.port\")\n")
	b.WriteString(fmt.Sprintf("tcp_table:add(%d, %s_proto)\n", 8080, strcase.ToSnake(rootPacket.Name)))
	output[strcase.ToSnake(rootPacket.Name)+".lua"] = []byte(b.String())
	return output, nil
}

func (g LuaWspGenerator) generateSubDissector(parentName string, pkt model.Packet) string {
	var b strings.Builder

	for _, f := range pkt.Fields {
		if f.InerObject != nil {
			b.WriteString(g.generateSubDissector(parentName, *f.InerObject))
			b.WriteString("\n")
		}
	}

	b.WriteString(fmt.Sprintf("local function dissect_%s(buf, pinfo, tree, offset)\n", strcase.ToSnake(pkt.Name)))
	b.WriteString(AddIndent4ln(fmt.Sprintf("local subtree = tree:add(%s_proto, buf(offset, 1), \"%s\")", strcase.ToSnake(parentName), pkt.Name)))
	if len(pkt.Fields) > 0 {
		for _, f := range pkt.Fields {
			if isMatchField(f, pkt) && f.GetType() != "match" {
				b.WriteString(AddIndent4ln(g.decodeFieldForLocal(f)))
			}
			if f.IsRepeat {
				b.WriteString(AddIndent4ln(g.decodeList("subtree", pkt, f)))
			} else {
				b.WriteString(AddIndent4ln(g.decodeField("subtree", pkt, f)))
			}
		}
	} else {
		b.WriteString(AddIndent4ln("subtree:append_text(\" (No Body)\")"))
	}
	b.WriteString(AddIndent4ln("return offset"))
	b.WriteString("end\n")
	return b.String()
}

func (g LuaWspGenerator) generateMainDissector(rootPacket model.Packet) string {
	var b strings.Builder

	for _, f := range rootPacket.Fields {
		if f.InerObject != nil {
			b.WriteString(g.generateSubDissector(rootPacket.Name, *f.InerObject))
			b.WriteString("\n")
		}
	}

	b.WriteString(fmt.Sprintf("function %s_proto.dissector(buf, pinfo, tree)\n", strcase.ToSnake(rootPacket.Name)))
	b.WriteString(AddIndent4ln(fmt.Sprintf("pinfo.cols.protocol = \"%s\"", strcase.ToSnake(rootPacket.Name))))
	b.WriteString(AddIndent4ln("local offset = 0"))
	for _, f := range rootPacket.Fields {
		if isMatchField(f, rootPacket) && f.GetType() != "match" {
			b.WriteString(AddIndent4ln(g.decodeFieldForLocal(f)))
		}
		if f.IsRepeat {
			b.WriteString(AddIndent4ln(g.decodeList("tree", rootPacket, f)))
		} else {
			b.WriteString(AddIndent4ln(g.decodeField("tree", rootPacket, f)))
		}
	}
	b.WriteString("end\n")
	return b.String()
}

func (g LuaWspGenerator) decodeList(treeName string, p model.Packet, f model.Field) string {
	var b strings.Builder
	b.WriteString(g.decodeListSize(treeName, p, f) + "\n")
	b.WriteString(fmt.Sprintf("for i=1,%s_%s_%s do\n", strcase.ToSnake(p.Name), strcase.ToSnake(f.Name), "size"))
	code := g.decodeField(treeName, p, f)
	if f.InerObject != nil {
		code = "offset = " + code
	}
	b.WriteString(AddIndent4ln(code))
	b.WriteString(AddIndent4ln(fmt.Sprintf("pinfo.cols.info:append(\" %s[\"..i..\"]\")", f.Name)))
	b.WriteString("end")
	return b.String()
}

func isMatchField(f model.Field, rootPacket model.Packet) bool {
	for _, field := range rootPacket.Fields {
		if field.GetType() == "match" && f.Name == field.MatchType {
			return true
		}
	}
	return false
}

const decodeFieldTmpl = `{{.TreeName}}:{{.Add}}(fields.{{.Name}}, buf(offset, {{.Type.Size}}))
offset = offset + {{.Type.Size}}`

func (g LuaWspGenerator) decodeListSize(treeName string, p model.Packet, f model.Field) string {
	var prefix = g.config.ListLenPrefixLenType
	switch prefix {
	case "i8", "u8", "i16", "u16", "i32", "u32", "i64", "u64":
		sizeName := fmt.Sprintf("%s_%s_%s", strcase.ToSnake(p.Name), strcase.ToSnake(f.Name), "size")
		luaType, ok := luaBasicTypeMap[prefix]
		if !ok {
			return "-- unsupported numeric type: " + prefix + "\n"
		}
		decodeName := luaType.Be
		if g.config.LittleEndian {
			decodeName = luaType.Le
		}
		code := fmt.Sprintf("local %s = buf(offset, %d):%s()\n", sizeName, luaType.Size, decodeName)
		code += fmt.Sprintf("%s:add(\"%s Size: \".. %s, buf(offset, %d))\n", treeName, f.Name, sizeName, luaType.Size)
		code += fmt.Sprintf("offset = offset + %d", luaType.Size)
		return code
	default:
		return "-- unsupported numeric type: " + f.GetType() + "\n"
	}
}

func (g LuaWspGenerator) decodeStringLen(treeName string, p model.Packet, f model.Field) string {
	var prefix = g.config.StringLenPrefixLenType
	switch prefix {
	case "i8", "u8", "i16", "u16", "i32", "u32", "i64", "u64":
		lenName := fmt.Sprintf("%s_%s_%s", strcase.ToSnake(p.Name), strcase.ToSnake(f.Name), "len")
		luaType, ok := luaBasicTypeMap[prefix]
		if !ok {
			return "-- unsupported numeric type: " + prefix + "\n"
		}
		decodeName := luaType.Be
		if g.config.LittleEndian {
			decodeName = luaType.Le
		}
		code := fmt.Sprintf("local %s = buf(offset, %d):%s()\n", lenName, luaType.Size, decodeName)
		code += fmt.Sprintf("%s:add(\"%s Len: \".. %s, buf(offset, %d))\n", treeName, f.Name, lenName, luaType.Size)
		code += fmt.Sprintf("offset = offset + %d", luaType.Size)
		return code
	default:
		return "-- unsupported numeric type: " + f.GetType()
	}
}

func (g LuaWspGenerator) decodeFieldForLocal(f model.Field) string {
	switch f.GetType() {
	case "i8", "u8", "i16", "u16", "i32", "u32", "i64", "u64", "f32", "f64", "char":
		luaType, ok := luaBasicTypeMap[f.GetType()]
		if !ok {
			return "-- unsupported numeric type: " + f.GetType() + "\n"
		}
		decodeName := luaType.Be
		if g.config.LittleEndian {
			decodeName = luaType.Le
		}
		return fmt.Sprintf("local %s = buf(offset, %d):%s()", strcase.ToSnake(f.Name), luaType.Size, decodeName)
	case "string":
		luaType, ok := luaBasicTypeMap[g.config.StringLenPrefixLenType]
		if !ok {
			return "-- unsupported numeric type: " + f.GetType() + "\n"
		}
		decodeName := luaType.Be
		if g.config.LittleEndian {
			decodeName = luaType.Le
		}
		var b strings.Builder
		b.WriteString(fmt.Sprintf("local _len = buf(offset, %d):%s()", luaType.Size, decodeName) + "\n")
		b.WriteString(fmt.Sprintf("local %s = buf(offset, _len):string()", strcase.ToSnake(f.Name)))
		return b.String()
	default:
		if size, ok := ParseCharArrayType(f.GetType()); ok {
			return fmt.Sprintf("local %s = buf(offset, %s):string()", strcase.ToSnake(f.Name), size)
		}
		return "-- unsupported type: " + f.GetType() + "\n"
	}
}

func (g LuaWspGenerator) decodeField(treeName string, p model.Packet, f model.Field) string {
	switch f.GetType() {
	case "i8", "u8", "i16", "u16", "i32", "u32", "i64", "u64", "f32", "f64", "char":
		luaType, ok := luaBasicTypeMap[f.GetType()]
		if !ok {
			return "-- unsupported numeric type: " + f.GetType() + "\n"
		}
		addMethod := "add"
		if g.config.LittleEndian {
			addMethod = "le_add"
		}
		data := map[string]interface{}{
			"Name":     fmt.Sprintf("%s_%s", strcase.ToSnake(p.Name), strcase.ToSnake(f.Name)),
			"TreeName": treeName,
			"Add":      addMethod,
			"Type":     luaType,
		}
		code, err := RenderToString(decodeFieldTmpl, "lua", data)
		if err != nil {
			return "-- error generating code: " + err.Error() + "\n"
		}
		return code
	case "match":
		if len(f.MatchPairs) == 0 {
			return ""
		}
		var b strings.Builder
		for i, pair := range f.MatchPairs {
			if i != 0 {
				b.WriteString("else")
			}
			b.WriteString(fmt.Sprintf("if %s == %s then -- %s\n", strcase.ToSnake(f.MatchType), pair.Key, pair.Value))
			b.WriteString(AddIndent4ln(fmt.Sprintf("dissect_%s(buf, pinfo, tree, offset)", strcase.ToSnake(pair.Value))))
			b.WriteString(AddIndent4ln(fmt.Sprintf("pinfo.cols.info:set(\"%s\")", pair.Value)))
		}
		b.WriteString("end")
		return b.String()
	case "string":
		var b strings.Builder
		b.WriteString(g.decodeStringLen(treeName, p, f) + "\n")
		lenName := fmt.Sprintf("%s_%s_%s", strcase.ToSnake(p.Name), strcase.ToSnake(f.Name), "len")
		b.WriteString(fmt.Sprintf("%s:add(fields.%s_%s, buf(offset, %s))\n", treeName, strcase.ToSnake(p.Name), strcase.ToSnake(f.Name), lenName))
		b.WriteString(fmt.Sprintf("offset = offset + %s", lenName))
		return b.String()
	default:
		var b strings.Builder
		if size, ok := ParseCharArrayType(f.GetType()); ok {
			b.WriteString(fmt.Sprintf("%s:add(fields.%s_%s, buf(offset, %s))\n", treeName, strcase.ToSnake(p.Name), strcase.ToSnake(f.Name), size))
			b.WriteString(fmt.Sprintf("offset = offset + %s", size))
			return b.String()
		} else if f.InerObject != nil {
			b.WriteString(fmt.Sprintf("dissect_%s(buf, pinfo, subtree, offset)", strcase.ToSnake(f.Name)))
			if !f.IsRepeat {
				b.WriteString("\n")
				b.WriteString(fmt.Sprintf("pinfo.cols.info:set(\"%s\")", f.Name))
			}
			return b.String()
		}
		return "-- unsupported type: " + f.GetType() + "\n"
	}
}

func (g LuaWspGenerator) generateFieldDefinition(model *model.BinaryModel) string {
	var b strings.Builder
	b.WriteString("local fields = {\n")
	for _, pkt := range model.Packets {
		b.WriteString(g.generateFieldDefinitionFromPacket(model, &pkt))
	}
	b.WriteString("}\n\n")

	return b.String()
}

func (g LuaWspGenerator) generateFieldDefinitionFromPacket(mdl *model.BinaryModel, pkt *model.Packet) string {
	var b strings.Builder
	b.WriteString(AddIndent4ln(fmt.Sprintf("-- Field from %s", pkt.Name)))
	for _, f := range pkt.Fields {
		fieldName := strcase.ToSnake(pkt.Name) + "_" + strcase.ToSnake(f.Name)
		filterName := strcase.ToSnake(pkt.Name) + "." + strcase.ToSnake(f.Name)
		switch f.GetType() {
		case "char":
			b.WriteString(AddIndent4ln(fmt.Sprintf("%s = ProtoField.char(\"%s\", \"%s\", base.OCT),",
				fieldName, filterName, f.Name)))
		case "i8", "u8", "i16", "u16", "i32", "u32", "i64", "u64", "f32", "f64":
			luaType, ok := luaBasicTypeMap[f.GetType()]
			if !ok {
				b.WriteString("-- unsupported numeric type: " + f.GetType() + "\n")
			} else {
				b.WriteString(AddIndent4ln(fmt.Sprintf("%s = ProtoField.%s(\"%s\", \"%s\", base.DEC),",
					fieldName, luaType.LuaType, filterName, f.Name)))
			}
		case "string", "char[]":
			b.WriteString(AddIndent4ln(fmt.Sprintf("%s = ProtoField.string(\"%s\", \"%s\"),",
				fieldName, filterName, f.Name)))
		case "bytes":
			b.WriteString(AddIndent4ln(fmt.Sprintf("%s = ProtoField.bytes(\"%s\", \"%s\"),",
				fieldName, filterName, f.Name)))
		case "bool":
			b.WriteString(AddIndent4ln(fmt.Sprintf("%s = ProtoField.bool(\"%s\", \"%s\"),",
				fieldName, filterName, f.Name)))
		default:
			_, ok := ParseCharArrayType(f.GetType())
			if ok {
				b.WriteString(AddIndent4ln(fmt.Sprintf("%s = ProtoField.string(\"%s\", \"%s\"),",
					fieldName, filterName, f.Name)))
			} else if p, ok := mdl.PacketsMap[f.Name]; ok {
				b.WriteString(g.generateFieldDefinitionFromPacket(mdl, &p))
			} else if f.InerObject != nil {
				b.WriteString(g.generateFieldDefinitionFromPacket(mdl, f.InerObject))
			} else {
				b.WriteString(AddIndent4ln(fmt.Sprintf("-- Unsupported type: %s", f.GetType())))
			}
		}
	}
	return b.String()
}
