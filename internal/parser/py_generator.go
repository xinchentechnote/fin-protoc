package parser

import (
	"fmt"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/xinchentechnote/fin-protoc/internal/model"
)

// PyType represents a Python type for a field in a packet.
type PyType struct {
	Name         string
	BasicType    string
	TestValue    string
	DefaultValue string
	Le           string
	Size         uint32
}

// pyBasicTypeMap maps field types to their Python representations.
var pyBasicTypeMap = map[string]PyType{
	"i8":  {"i8", "i8", "1", "0", "i8", 1},
	"i16": {"i16", "i16", "2", "0", "i16_le", 2},
	"i32": {"i32", "i32", "4", "0", "i32_le", 4},
	"i64": {"i64", "i64", "8", "0", "i64_le", 8},
	"u8":  {"u8", "u8", "1", "0", "u8", 1},
	"u16": {"u16", "u16", "2", "0", "u16_le", 2},
	"u32": {"u32", "u32", "4", "0", "u32_le", 4},
	"u64": {"u64", "u64", "8", "0", "u64_le", 8},
	"f32": {"f32", "f32", "4", "0", "f32_le", 4},
	"f64": {"f64", "f64", "8", "0", "f64_le", 8},
}

// PythonGenerator a go code generator
type PythonGenerator struct {
	binModel *model.BinaryModel
	hasGen   map[string]*model.Packet
}

// NewPythonGenerator new
func NewPythonGenerator(binModel *model.BinaryModel) *PythonGenerator {
	return &PythonGenerator{
		binModel: binModel,
		hasGen:   make(map[string]*model.Packet),
	}
}

// GetConfig get Configuration
func (g PythonGenerator) GetConfig() *model.Configuration {
	return g.binModel.Config
}

// Generate python code
func (g PythonGenerator) Generate(binModel *model.BinaryModel) (map[string][]byte, error) {
	output := make(map[string][]byte)
	// Generate code for each packet
	var code = g.generateCode(binModel)
	output[strcase.ToSnake(binModel.RootPacket.Name)+".py"] = []byte(code)
	// Generate test code for each packet
	var testCode = g.generateTestCode(binModel)
	output[strcase.ToSnake(binModel.RootPacket.Name)+"_test.py"] = []byte(testCode)
	return output, nil
}

func (g PythonGenerator) generateCode(binModel *model.BinaryModel) string {
	var code strings.Builder
	code.WriteString("# Code generated by fin-protoc. DO NOT EDIT.\n")
	code.WriteString(`from bytebuf import ByteBuf
from checksum import create_checksum_service
from message_factory import MessageFactory
from codec import *`)
	code.WriteString("\n\n")
	for _, pkt := range binModel.Packets {
		if pkt.IsRoot {
			continue
		}
		code.WriteString(g.generateCodeForPacket(pkt))
		code.WriteString("\n\n")
	}

	code.WriteString(g.generateCodeForPacket(binModel.RootPacket))
	code.WriteString("\n\n")
	return code.String()
}

func (g PythonGenerator) generateCodeForPacket(p *model.Packet) string {
	if _, ok := g.hasGen[p.Name]; ok {
		return ""
	}
	g.hasGen[p.Name] = p
	var b strings.Builder
	// gen iner object
	for _, f := range p.Fields {
		switch f := f.Attr.(type) {
		case *model.ObjectFieldAttribute:
			b.WriteString(g.generateCodeForPacket(f.RefPacket))
			b.WriteString("\n")
		case *model.MatchFieldAttribute:
			for _, pair := range f.MatchPairs {
				mp := g.binModel.PacketsMap[pair.Value]
				packetCode := g.generateCodeForPacket(mp)
				if packetCode != "" {
					b.WriteString(packetCode)
					b.WriteString("\n")
				}
			}
		}
	}
	//class RcBinaryMessageFactory(MessageFactory[int, BinaryCodec]): ...

	for key, pairs := range p.MatchFields {
		f := p.FieldMap[key]
		_, ok := pyBasicTypeMap[f.GetType()]
		pyt := "str"
		if ok {
			pyt = "int"
		}
		b.WriteString(fmt.Sprintf("class %sMessageFactory(MessageFactory[%s, BinaryCodec]): ...\n", strcase.ToCamel(p.Name), pyt))
		b.WriteString(fmt.Sprintf("%sMessageFactory = %sMessageFactory()\n", strcase.ToLowerCamel(p.Name), strcase.ToCamel(p.Name)))
		for _, pair := range pairs {
			b.WriteString(fmt.Sprintf("%sMessageFactory.register(%s, %s)\n", strcase.ToLowerCamel(p.Name), pair.Key, pair.Value))
		}
		b.WriteString("\n")
		b.WriteString("\n")
	}

	// gen class
	b.WriteString(fmt.Sprintf("class %s(BinaryCodec):\n", strcase.ToCamel(p.Name)))
	// gen __init_ method
	b.WriteString(AddIndent4ln(g.generateInitMethod(p)))
	// gen encode method
	b.WriteString(AddIndent4ln(g.generateEncodeMethod(p)))
	// gen decode method
	b.WriteString(AddIndent4ln(g.generateDecodeMethod(p)))
	// gen __eq__ method
	b.WriteString(AddIndent4ln(g.generateEqMethod(p)))
	return b.String()
}

func (g PythonGenerator) generateEqMethod(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("def __eq__(self, other):\n")
	b.WriteString("    if not isinstance(other, self.__class__):\n")
	b.WriteString("        return False\n")
	if len(p.Fields) == 0 {
		b.WriteString("    return True\n")
		return b.String()
	}
	b.WriteString("    return all([\n")
	for i, f := range p.Fields {
		fieldName := strcase.ToSnake(f.Name)
		b.WriteString(fmt.Sprintf("        self.%s == other.%s", fieldName, fieldName))
		if i < len(p.Fields)-1 {
			b.WriteString(",\n")
		} else {
			b.WriteString("\n")
		}
	}
	b.WriteString("    ])\n")
	b.WriteString("    \n")
	return b.String()
}

func (g PythonGenerator) generateDecodeMethod(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("def decode(self, buffer: ByteBuf):\n")
	if len(p.Fields) == 0 {
		b.WriteString("    pass\n")
		return b.String()
	}
	for _, f := range p.Fields {
		if f.IsRepeat {
			if g.GetConfig().LittleEndian {
				b.WriteString(fmt.Sprintf("    size = read_len_le(buffer, '%s')\n", g.GetConfig().ListLenPrefixLenType))
			} else {
				b.WriteString(fmt.Sprintf("    size = read_len(buffer, '%s')\n", g.GetConfig().ListLenPrefixLenType))
			}
			b.WriteString("    for i in range(size):\n")
			b.WriteString(AddIndent4ln(g.generateDecodeField(p, f)))
		} else {
			b.WriteString(g.generateDecodeField(p, f))
		}
	}
	return b.String()
}

// GetPadding field.Padding or config.Padding
func (g PythonGenerator) GetPadding(f *model.Field) *model.Padding {
	padding := g.GetConfig().Padding
	if fs, ok := f.Attr.(*model.FixedStringFieldAttribute); ok {
		if fs.Padding != nil {
			padding = fs.Padding
		}
	}
	if padding == nil {
		return nil
	}

	if padding.PadChar == "'\x00'" || padding.PadChar == "'\\x00'" {
		padding.PadChar = "'\\x00'"
	}

	return padding
}

func (g PythonGenerator) generateDecodeField(p *model.Packet, f *model.Field) string {
	var b strings.Builder
	fieldName := strcase.ToSnake(f.Name)
	padding := g.GetPadding(f)
	switch c := f.Attr.(type) {
	case *model.BasicFieldAttribute, *model.LengthFieldAttribute, *model.CheckSumFieldAttribute:
		if typ, ok := pyBasicTypeMap[f.GetType()]; ok {
			read := typ.BasicType
			if g.GetConfig().LittleEndian {
				read = typ.Le
			}
			if f.IsRepeat {
				b.WriteString(fmt.Sprintf("    self.%s.append(buffer.read_%s())\n", fieldName, read))
			} else {
				b.WriteString(fmt.Sprintf("    self.%s = buffer.read_%s()\n", fieldName, read))
			}
		}
	case *model.FixedStringFieldAttribute:
		if !padding.IsDefault() {
			fromLeft := "False"
			if padding.PadLeft {
				fromLeft = "True"
			}
			if f.IsRepeat {
				b.WriteString(fmt.Sprintf("    self.%s.append(read_fixed_string(buffer, %d, 'utf-8', %s, %s))\n", fieldName, c.Length, padding.PadChar, fromLeft))
			} else {
				b.WriteString(fmt.Sprintf("    self.%s = read_fixed_string(buffer, %d, 'utf-8', %s, %s)\n", fieldName, c.Length, padding.PadChar, fromLeft))
			}
		} else {
			if f.IsRepeat {
				b.WriteString(fmt.Sprintf("    self.%s.append(read_fixed_string(buffer,  %d, 'utf-8'))\n", fieldName, c.Length))
			} else {
				b.WriteString(fmt.Sprintf("    self.%s = read_fixed_string(buffer, %d, 'utf-8')\n", fieldName, c.Length))
			}
		}
	case *model.DynamicStringFieldAttribute:
		var le string
		if g.GetConfig().LittleEndian {
			le = "_le"
		}
		if f.IsRepeat {
			b.WriteString(fmt.Sprintf("    self.%s.append(read_string%s(buffer,'%s'))\n", fieldName, le, g.GetConfig().StringLenPrefixLenType))
		} else {
			b.WriteString(fmt.Sprintf("    self.%s = read_string%s(buffer,'%s')\n", fieldName, le, g.GetConfig().StringLenPrefixLenType))
		}
	case *model.ObjectFieldAttribute:
		if f.IsRepeat {
			b.WriteString(fmt.Sprintf("    _%s = %s()\n", strcase.ToSnake(f.GetType()), strcase.ToCamel(f.GetType())))
			b.WriteString(fmt.Sprintf("    _%s.decode(buffer)\n", strcase.ToSnake(f.GetType())))
			b.WriteString(fmt.Sprintf("    self.%s.append(_%s)\n", fieldName, strcase.ToSnake(f.GetType())))
		} else {
			b.WriteString(fmt.Sprintf("    self.%s = %s()\n", fieldName, strcase.ToCamel(f.GetType())))
			b.WriteString(fmt.Sprintf("    self.%s.decode(buffer)\n", fieldName))
		}
	case *model.MatchFieldAttribute:
		b.WriteString(fmt.Sprintf("    self.%s = %sMessageFactory.create(self.%s)\n", fieldName, strcase.ToLowerCamel(p.Name), strcase.ToSnake(c.MatchKeyField.Name)))
		b.WriteString(fmt.Sprintf("    self.%s.decode(buffer)\n", fieldName))
	default:
		b.WriteString("-- unsupported type: " + f.GetType() + "\n")
	}
	return b.String()
}

func (g PythonGenerator) generateEncodeMethod(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("def encode(self, buffer: ByteBuf):\n")
	if len(p.Fields) == 0 {
		b.WriteString("    pass\n")
		return b.String()
	}

	for _, f := range p.Fields {
		fieldName := strcase.ToSnake(f.Name)
		if _, ok := f.LenAttr.(*model.LengthFieldAttribute); ok {
			b.WriteString(fmt.Sprintf("    %s_start = buffer.write_index\n", fieldName))
			b.WriteString(fmt.Sprintf("    self.%s.encode(buffer)\n", fieldName))
			b.WriteString(fmt.Sprintf("    %s_end = buffer.write_index\n", fieldName))
			LengthFieldName := strcase.ToSnake(p.LengthField.Name)
			b.WriteString(fmt.Sprintf("    self.%s = %s_end - %s_start\n", LengthFieldName, fieldName, fieldName))
			typ := pyBasicTypeMap[p.LengthField.GetType()]
			if g.GetConfig().LittleEndian {
				b.WriteString(fmt.Sprintf("    buffer.write_%s_at(%s_pos, self.%s)\n", typ.Le, LengthFieldName, LengthFieldName))
			} else {
				b.WriteString(fmt.Sprintf("    buffer.write_%s_at(%s_pos, self.%s)\n", typ.BasicType, LengthFieldName, LengthFieldName))
			}
			continue
		}
		switch c := f.Attr.(type) {
		case *model.LengthFieldAttribute:
			typ := pyBasicTypeMap[f.GetType()]
			b.WriteString(fmt.Sprintf("    %s_pos = buffer.write_index\n", fieldName))
			if g.GetConfig().LittleEndian {
				b.WriteString(fmt.Sprintf("    buffer.write_%s(0)\n", typ.Le))
			} else {
				b.WriteString(fmt.Sprintf("    buffer.write_%s(0)\n", typ.BasicType))
			}
		case *model.CheckSumFieldAttribute:
			b.WriteString(fmt.Sprintf("    service = create_checksum_service(%s)\n", c.CheckSumType))
			b.WriteString("    if service :\n")
			b.WriteString(fmt.Sprintf("        self.%s = service.calc(buffer)\n", fieldName))
			if typ, ok := pyBasicTypeMap[f.GetType()]; ok {
				if g.GetConfig().LittleEndian {
					b.WriteString(fmt.Sprintf("    buffer.write_%s(self.%s)\n", typ.Le, fieldName))
				} else {
					b.WriteString(fmt.Sprintf("    buffer.write_%s(self.%s)\n", typ.BasicType, fieldName))
				}
			}
		default:
			if f.IsRepeat {
				typ := pyBasicTypeMap[g.GetConfig().ListLenPrefixLenType]
				b.WriteString(fmt.Sprintf("    size = len(self.%s)\n", fieldName))
				if g.GetConfig().LittleEndian {
					b.WriteString(fmt.Sprintf("    buffer.write_%s(size)\n", typ.Le))
				} else {
					b.WriteString(fmt.Sprintf("    buffer.write_%s(size)\n", typ.BasicType))
				}
				b.WriteString("    for i in range(size):\n")
				b.WriteString(AddIndent4ln(g.generateEncodeField(f)))
			} else {
				b.WriteString(g.generateEncodeField(f))
			}
		}

	}
	return b.String()
}

func (g PythonGenerator) generateEncodeField(f *model.Field) string {
	var b strings.Builder
	fieldName := strcase.ToSnake(f.Name)
	if f.IsRepeat {
		fieldName += "[i]"
	}
	padding := g.GetPadding(f)
	switch c := f.Attr.(type) {
	case *model.BasicFieldAttribute, *model.CheckSumFieldAttribute:
		if typ, ok := pyBasicTypeMap[f.GetType()]; ok {
			if g.GetConfig().LittleEndian {
				b.WriteString(fmt.Sprintf("    buffer.write_%s(self.%s)\n", typ.Le, fieldName))
			} else {
				b.WriteString(fmt.Sprintf("    buffer.write_%s(self.%s)\n", typ.BasicType, fieldName))
			}
		}
	case *model.FixedStringFieldAttribute:
		fromLeft := "False"
		if !padding.IsDefault() && padding.PadLeft {
			fromLeft = "True"
		}
		if !padding.IsDefault() {
			b.WriteString(fmt.Sprintf("    write_fixed_string(buffer, self.%s, %d, 'utf-8', %s, %s)\n", fieldName, c.Length, padding.PadChar, fromLeft))
		} else {
			b.WriteString(fmt.Sprintf("    write_fixed_string(buffer, self.%s, %d, 'utf-8')\n", fieldName, c.Length))
		}
	case *model.DynamicStringFieldAttribute:
		if g.GetConfig().LittleEndian {
			b.WriteString(fmt.Sprintf("    write_string_le(buffer, self.%s, '%s')\n", fieldName, g.GetConfig().StringLenPrefixLenType))
		} else {
			b.WriteString(fmt.Sprintf("    write_string(buffer, self.%s, '%s')\n", fieldName, g.GetConfig().StringLenPrefixLenType))
		}
	case *model.ObjectFieldAttribute:
		b.WriteString(fmt.Sprintf("    self.%s.encode(buffer)\n", fieldName))
	case *model.MatchFieldAttribute:
		b.WriteString(fmt.Sprintf("    if self.%s is not None:\n", fieldName))
		b.WriteString(fmt.Sprintf("        self.%s.encode(buffer)\n", fieldName))
	default:
		b.WriteString("-- unsupported type: " + f.GetType() + "\n")
	}
	return b.String()
}

func (g PythonGenerator) generateInitMethod(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("def __init__(self):\n")
	if len(p.Fields) == 0 {
		b.WriteString("    pass\n")
		return b.String()
	}
	for _, f := range p.Fields {
		fieldName := strcase.ToSnake(f.Name)
		if f.IsRepeat {
			b.WriteString(fmt.Sprintf("    self.%s = []\n", fieldName))
			continue
		}
		switch f.Attr.(type) {
		case *model.BasicFieldAttribute, *model.LengthFieldAttribute, *model.CheckSumFieldAttribute:
			if _, ok := pyBasicTypeMap[f.GetType()]; ok {
				b.WriteString(fmt.Sprintf("    self.%s = %s\n", fieldName, pyBasicTypeMap[f.GetType()].DefaultValue))
			}
		case *model.FixedStringFieldAttribute, *model.DynamicStringFieldAttribute:
			b.WriteString(fmt.Sprintf("    self.%s = ''\n", fieldName))
		default:
			b.WriteString(fmt.Sprintf("    self.%s = None\n", fieldName))
		}
	}
	return b.String()
}

func (g PythonGenerator) generateTestCode(binModel *model.BinaryModel) string {
	var b strings.Builder
	b.WriteString("# Code generated by fin-protoc. DO NOT EDIT.\n")
	b.WriteString("import unittest\n\n")
	b.WriteString(fmt.Sprintf("from %s import *\n\n", strcase.ToSnake(binModel.RootPacket.Name)))
	for _, pkt := range binModel.Packets {
		b.WriteString(g.generateTestCodeForPacket(pkt))
		b.WriteString("\n\n")
	}
	b.WriteString("if __name__ == '__main__':\n")
	b.WriteString("    unittest.main()\n")
	return b.String()
}

func (g PythonGenerator) generateTestCodeForPacket(packet *model.Packet) string {
	var b strings.Builder
	packageName := strcase.ToCamel(packet.Name)
	b.WriteString(fmt.Sprintf("class Test%s(unittest.TestCase):\n", packageName))
	b.WriteString("    def setUp(self):\n")
	b.WriteString(AddIndent4ln(AddIndent4(g.generateNewInstance("self.packet", packet))))
	b.WriteString("\n")
	b.WriteString("    def test_encode_decode(self):\n")
	b.WriteString("        buf = ByteBuf()\n")
	b.WriteString("        self.packet.encode(buf)\n")
	b.WriteString(fmt.Sprintf("        decoded_packet = %s()\n", packageName))
	b.WriteString("        decoded_packet.decode(buf)\n")
	b.WriteString("        self.assertEqual(decoded_packet, self.packet)\n")
	b.WriteString("\n")
	return b.String()
}

func (g PythonGenerator) generateNewInstance(name string, packet *model.Packet) string {
	var b strings.Builder
	for _, f := range packet.Fields {
		fieldName := strcase.ToSnake(f.Name)
		if of, ok := f.Attr.(*model.ObjectFieldAttribute); ok {
			b.WriteString(g.generateNewInstance(fieldName, of.RefPacket))
		}
		if mf, ok := f.Attr.(*model.MatchFieldAttribute); ok {
			mp := g.binModel.PacketsMap[mf.MatchPairs[0].Value]
			b.WriteString(g.generateNewInstance(fieldName, mp))
		}
	}
	b.WriteString(fmt.Sprintf("%s = %s()\n", name, strcase.ToCamel(packet.Name)))
	for _, f := range packet.Fields {
		fieldName := strcase.ToSnake(f.Name)
		if mf, ok := f.Attr.(*model.MatchFieldAttribute); ok {
			if len(mf.MatchPairs) > 0 {
				key := mf.MatchPairs[0].Key
				b.WriteString(fmt.Sprintf("%s.%s = %s\n", name, strcase.ToSnake(mf.MatchKeyField.Name), key))
				b.WriteString(fmt.Sprintf("%s.%s = %s\n", name, fieldName, g.generateTestValue(f)))
			}
			continue
		}
		if packet.MatchFields[f.Name] != nil {
			continue
		}
		b.WriteString(fmt.Sprintf("%s.%s = %s\n", name, fieldName, g.generateTestValue(f)))
	}

	return b.String()
}

func (g PythonGenerator) generateTestValue(f *model.Field) string {
	var testValue string
	fieldName := strcase.ToSnake(f.Name)

	switch c := f.Attr.(type) {
	case *model.BasicFieldAttribute, *model.LengthFieldAttribute, *model.CheckSumFieldAttribute:
		if typ, ok := pyBasicTypeMap[f.GetType()]; ok {
			testValue = typ.TestValue
		}
	case *model.FixedStringFieldAttribute:
		testValue = "\"" + strings.Repeat("x", c.Length) + "\""
	case *model.DynamicStringFieldAttribute:
		testValue = "\"hello\""
	case *model.MatchFieldAttribute, *model.ObjectFieldAttribute:
		testValue = fieldName
	}

	if f.IsRepeat {
		return "[" + testValue + "]"
	}
	return testValue
}
