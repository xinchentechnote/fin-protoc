package parser

import (
	"fmt"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/xinchentechnote/fin-protoc/internal/model"
)

// PyType represents a Python type for a field in a packet.
type PyType struct {
	Name         string
	BasicType    string
	TestValue    string
	DefaultValue string
	Le           string
	Size         uint32
}

// pyBasicTypeMap maps field types to their Python representations.
var pyBasicTypeMap = map[string]PyType{
	"i8":  {"i8", "i8", "1", "0", "i8", 1},
	"i16": {"i16", "i16", "2", "0", "i16_le", 2},
	"i32": {"i32", "i32", "4", "0", "i32_le", 4},
	"i64": {"i64", "i64", "8", "0", "i64_le", 8},
	"u8":  {"u8", "u8", "1", "0", "u8", 1},
	"u16": {"u16", "u16", "2", "0", "u16_le", 2},
	"u32": {"u32", "u32", "4", "0", "u32_le", 4},
	"u64": {"u64", "u64", "8", "0", "u64_le", 8},
	"f32": {"f32", "f32", "4", "0", "f32_le", 4},
	"f64": {"f64", "f64", "8", "0", "f64_le", 8},
}

// PythonGenerator a go code generator
type PythonGenerator struct {
	config   *GeneratorConfig
	binModel *model.BinaryModel
}

// NewPythonGenerator new
func NewPythonGenerator(config *GeneratorConfig, binModel *model.BinaryModel) *PythonGenerator {
	return &PythonGenerator{
		config:   config,
		binModel: binModel,
	}
}

// Generate python code
func (g PythonGenerator) Generate(binModel *model.BinaryModel) (map[string][]byte, error) {
	output := make(map[string][]byte)
	// Generate code for each packet
	var code = g.generateCode(binModel)
	output[strcase.ToSnake(binModel.RootPacket.Name)+".py"] = []byte(code)
	// Generate test code for each packet
	var testCode = g.generateTestCode(binModel)
	output[strcase.ToSnake(binModel.RootPacket.Name)+"_test.py"] = []byte(testCode)
	return output, nil
}

func (g PythonGenerator) generateCode(binModel *model.BinaryModel) string {
	var code strings.Builder
	code.WriteString("# Code generated by fin-protoc. DO NOT EDIT.\n")
	code.WriteString(`from ..bin_codec.bytebuf import ByteBuf
from ..bin_codec.codec import BinaryCodec`)
	code.WriteString("\n\n")
	for _, pkt := range binModel.PacketsMap {
		code.WriteString(g.generateCodeForPacket(&pkt))
		code.WriteString("\n\n")
	}
	return code.String()
}

func (g PythonGenerator) generateTestCode(binModel *model.BinaryModel) string {
	var b strings.Builder
	b.WriteString("# Code generated by fin-protoc. DO NOT EDIT.\n")
	b.WriteString("import unittest\n\n")
	b.WriteString(fmt.Sprintf("from %s import *\n\n", strcase.ToSnake(binModel.RootPacket.Name)))
	for _, pkt := range binModel.PacketsMap {
		b.WriteString(g.generateTestCodeForPacket(&pkt))
		b.WriteString("\n\n")
	}
	b.WriteString("if __name__ == '__main__':\n")
	b.WriteString("    unittest.main()\n")
	return b.String()
}

func (g PythonGenerator) generateTestCodeForPacket(packet *model.Packet) string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("class Test%s(unittest.TestCase):\n", strcase.ToCamel(packet.Name)))
	b.WriteString("    def setUp(self):\n")
	b.WriteString(fmt.Sprintf("        self.packet = %s()\n", strcase.ToCamel(packet.Name)))
	b.WriteString("\n")
	b.WriteString("    def test_encode_decode(self):\n")
	b.WriteString("        buf = ByteBuf()\n")
	b.WriteString("        self.packet.encode(buf)\n")
	b.WriteString(fmt.Sprintf("        decoded_packet = %s()\n", strcase.ToCamel(packet.Name)))
	b.WriteString("        decoded_packet.decode(buf)\n")
	b.WriteString("        self.assertEqual(decoded_packet, self.packet)\n")
	b.WriteString("\n")
	return b.String()
}

func (g PythonGenerator) generateCodeForPacket(p *model.Packet) string {
	var b strings.Builder
	// gen iner object
	for _, f := range p.Fields {
		if f.InerObject != nil {
			b.WriteString(g.generateCodeForPacket(f.InerObject))
		}
	}
	// gen class
	b.WriteString(fmt.Sprintf("class %s(BinaryCodec):\n", strcase.ToCamel(p.Name)))
	// gen __init_ method
	b.WriteString(AddIndent4ln(g.generateInitMethod(p)))
	// gen encode method
	b.WriteString(AddIndent4ln(g.generateEncodeMethod(p)))
	// gen decode method
	b.WriteString(AddIndent4ln(g.generateDecodeMethod(p)))
	return b.String()
}

func (g PythonGenerator) generateDecodeMethod(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("def decode(self, buffer: ByteBuf):\n")
	if len(p.Fields) == 0 {
		b.WriteString("    pass\n")
		return b.String()
	}
	for _, f := range p.Fields {
		if typ, ok := pyBasicTypeMap[f.Type]; ok {
			b.WriteString(fmt.Sprintf("    self.%s = buffer.read_%s()\n", strcase.ToSnake(f.Name), typ.Le))
			continue
		}
		if _, ok := ParseCharArrayType(f.Type); ok {
			b.WriteString(fmt.Sprintf("    self.%s = buffer.read_char_array()\n", strcase.ToSnake(f.Name)))
			continue
		}
		if f.Type == "string" || f.Type == "char[]" {
			b.WriteString(fmt.Sprintf("    self.%s = buffer.read_string()\n", strcase.ToSnake(f.Name)))
			continue
		}
		if f.InerObject != nil {
			b.WriteString(fmt.Sprintf("    self.%s = %s()\n", strcase.ToSnake(f.Name), strcase.ToCamel(f.InerObject.Name)))
			b.WriteString(fmt.Sprintf("    self.%s.decode(buffer)\n", strcase.ToSnake(f.Name)))
			continue
		}
		if _, ok := g.binModel.PacketsMap[f.Type]; ok {
			b.WriteString(fmt.Sprintf("    self.%s = %s()\n", strcase.ToSnake(f.Name), strcase.ToCamel(f.Type)))
			b.WriteString(fmt.Sprintf("    self.%s.decode(buffer)\n", strcase.ToSnake(f.Name)))
			continue
		}
		if f.Type == "match" {
			b.WriteString("    if buffer.has_more():\n")
			b.WriteString(fmt.Sprintf("        self.%s.decode(buffer)\n", strcase.ToSnake(f.Name)))
			continue
		}
	}
	return b.String()
}

func (g PythonGenerator) generateEncodeMethod(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("def encode(self, buffer: ByteBuf):\n")
	if len(p.Fields) == 0 {
		b.WriteString("    pass\n")
		return b.String()
	}

	for _, f := range p.Fields {
		if typ, ok := pyBasicTypeMap[f.Type]; ok {
			b.WriteString(fmt.Sprintf("    buffer.write_%s(self.%s)\n", typ.Le, strcase.ToSnake(f.Name)))
			continue
		}
		if _, ok := ParseCharArrayType(f.Type); ok {
			b.WriteString(fmt.Sprintf("    buffer.write_char_array(self.%s)\n", strcase.ToSnake(f.Name)))
			continue
		}
		if f.Type == "string" || f.Type == "char[]" {
			b.WriteString(fmt.Sprintf("    buffer.write_string(self.%s)\n", strcase.ToSnake(f.Name)))
			continue
		}
		if f.InerObject != nil {
			b.WriteString(fmt.Sprintf("    self.%s.encode(buffer)\n", strcase.ToSnake(f.Name)))
			continue
		}
		if _, ok := g.binModel.PacketsMap[f.Type]; ok {
			b.WriteString(fmt.Sprintf("    self.%s.encode(buffer)\n", strcase.ToSnake(f.Name)))
			continue
		}
		if f.Type == "match" {
			b.WriteString(fmt.Sprintf("    if self.%s is not None:\n", strcase.ToSnake(f.Name)))
			b.WriteString(fmt.Sprintf("        self.%s.encode(buffer)\n", strcase.ToSnake(f.Name)))
			continue
		}
		b.WriteString("-- unsupported type: " + f.Type + "\n")
	}
	return b.String()
}

func (g PythonGenerator) generateInitMethod(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("def __init__(self):\n")
	if len(p.Fields) == 0 {
		b.WriteString("    pass\n")
		return b.String()
	}
	for _, f := range p.Fields {
		if _, ok := pyBasicTypeMap[f.Type]; ok {
			b.WriteString(fmt.Sprintf("    self.%s = %s\n", strcase.ToSnake(f.Name), pyBasicTypeMap[f.Type].DefaultValue))
			continue
		}
		if _, ok := ParseCharArrayType(f.Type); ok {
			b.WriteString(fmt.Sprintf("    self.%s = []\n", strcase.ToSnake(f.Name)))
			continue
		}
		switch f.Type {
		case "string", "char[]":
			b.WriteString(fmt.Sprintf("    self.%s = ''\n", strcase.ToSnake(f.Name)))
		case "match":
			b.WriteString(fmt.Sprintf("    self.%s = None\n", strcase.ToSnake(f.Name)))
		default:
			b.WriteString(fmt.Sprintf("    self.%s = None\n", strcase.ToSnake(f.Name)))
		}
	}
	return b.String()
}
