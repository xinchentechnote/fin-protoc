package parser

import (
	"fmt"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/xinchentechnote/fin-protoc/internal/model"
)

// RustGenerator a rust code generator
type RustGenerator struct {
	config   *model.Configuration
	binModel *model.BinaryModel
}

// NewRustGenerator new
func NewRustGenerator(binModel *model.BinaryModel) *RustGenerator {
	return &RustGenerator{
		config:   binModel.Config,
		binModel: binModel,
	}
}

// Generate rust code
func (g RustGenerator) Generate(binModel *model.BinaryModel) (map[string][]byte, error) {
	output := make(map[string][]byte)
	for _, pkt := range binModel.PacketsMap {
		code := g.generateRustFileForPacket(pkt)
		output[strcase.ToSnake(pkt.Name)+".rs"] = []byte(code)
	}
	output["lib.rs"] = []byte(g.generateLibCode())
	return output, nil
}

func (g RustGenerator) generateRustFileForPacket(pkt *model.Packet) string {
	var b strings.Builder

	b.WriteString("// Code generated by fin-protoc. DO NOT EDIT.\n")
	// Rust use statements
	b.WriteString("use binary_codec::*;\n")
	b.WriteString("use byteorder::*;\n")
	b.WriteString("use bytes::{Buf, BufMut, Bytes, BytesMut};\n\n")
	//
	b.WriteString(g.generateUseCode(pkt))
	b.WriteString("\n")
	b.WriteString(g.generateMatchFieldEnumCode(pkt))
	b.WriteString("\n")
	b.WriteString(g.generateStructCode(pkt))

	return b.String()
}

func (g RustGenerator) generateLibCode() string {
	var b strings.Builder
	for _, pkt := range g.binModel.PacketsMap {
		b.WriteString(fmt.Sprintf("pub mod %s;\n", strcase.ToSnake(pkt.Name)))
	}
	return b.String()
}

// GenerateUseCode generates use statements for match pairs in the packet.
func (g RustGenerator) generateUseCode(msg *model.Packet) string {
	var b strings.Builder
	usePackets := make(map[string]struct{})
	for _, f := range msg.Fields {
		if mf, ok := f.Attr.(*model.MatchFieldAttribute); ok {
			for _, pair := range mf.MatchPairs {
				if _, exists := usePackets[pair.Value]; exists {
					continue // Skip if already added
				}
				usePackets[pair.Value] = struct{}{}
			}
		} else {

			if c, ok := f.Attr.(*model.ObjectFieldAttribute); ok && !c.IsIner {
				if _, exists := usePackets[c.PacketName]; exists {
					continue // Skip if already added
				}
				usePackets[c.PacketName] = struct{}{}
			}
		}
	}

	for key := range usePackets {
		b.WriteString(fmt.Sprintf("use crate::%s::*;\n", strcase.ToSnake(key)))
	}
	return b.String()
}

func (g RustGenerator) generateStructCode(pkt *model.Packet) string {
	var b strings.Builder
	for _, f := range pkt.Fields {
		if of, ok := f.Attr.(*model.ObjectFieldAttribute); ok && of.IsIner {
			b.WriteString(g.generateStructCode(of.RefPacket))
			b.WriteString("\n")
		}
	}
	b.WriteString("\n")
	// struct
	structName := strcase.ToCamel(pkt.Name)
	b.WriteString("#[derive(Debug, Clone, PartialEq)]\n")
	b.WriteString(fmt.Sprintf("pub struct %s {\n", structName))
	//struct fields
	for _, f := range pkt.Fields {
		if f.IsRepeat {
			b.WriteString(AddIndent4ln(fmt.Sprintf("pub %s: Vec<%s>,", g.GetFieldName(f), g.GetFieldType(structName, f))))
		} else {
			b.WriteString(AddIndent4ln(fmt.Sprintf("pub %s: %s,", g.GetFieldName(f), g.GetFieldType(structName, f))))
		}
	}
	b.WriteString("}\n\n")

	// impl BinaryCodec
	b.WriteString(fmt.Sprintf("impl BinaryCodec for %s {\n", structName))
	b.WriteString("\n")
	// encode()
	if len(pkt.Fields) == 0 {
		b.WriteString(AddIndent4ln("fn encode(&self, _buf: &mut BytesMut) {"))
	} else {
		b.WriteString(AddIndent4ln("fn encode(&self, buf: &mut BytesMut) {"))
	}
	for _, f := range pkt.Fields {
		b.WriteString(AddIndent4ln(AddIndent4(g.EncodeField(pkt, f))))
	}
	b.WriteString(AddIndent4ln("}"))
	b.WriteString("\n")
	// decode()
	if len(pkt.Fields) == 0 {
		b.WriteString(AddIndent4ln(fmt.Sprintf("fn decode(_buf: &mut Bytes) -> Option<%s> {", structName)))
	} else {
		b.WriteString(AddIndent4ln(fmt.Sprintf("fn decode(buf: &mut Bytes) -> Option<%s> {", structName)))
	}
	for _, f := range pkt.Fields {
		b.WriteString(AddIndent4ln(AddIndent4(g.DecodeField(structName, f))))
	}
	b.WriteString(AddIndent4ln(AddIndent4("Some(Self {")))
	for _, f := range pkt.Fields {
		b.WriteString(AddIndent4ln(AddIndent4(AddIndent4(g.GetFieldName(f) + ","))))
	}
	b.WriteString(AddIndent4ln(AddIndent4("})")))
	b.WriteString(AddIndent4ln("}"))
	b.WriteString("}\n")
	b.WriteString("\n")

	b.WriteString(g.generateUnitTestCode(pkt))
	return b.String()
}

// GetPadding field.Padding or config.Padding
func (g RustGenerator) GetPadding(f *model.Field) *model.Padding {
	padding := g.config.Padding
	if fs, ok := f.Attr.(*model.FixedStringFieldAttribute); ok {
		if fs.Padding != nil {
			padding = fs.Padding
		}
	}
	if padding == nil {
		return nil
	}
	if padding.PadChar == "'\\x00'" || padding.PadChar == "'\\u0000'" {
		padding.PadChar = "'\\0'"
	}
	return padding
}

// GetFieldType convert field type for rust
func (g RustGenerator) GetFieldType(parentName string, f *model.Field) string {
	switch f.Attr.(type) {
	case *model.FixedStringFieldAttribute, *model.DynamicStringFieldAttribute:
		return "String"
	case *model.MatchFieldAttribute:
		return parentName + f.Name + "Enum"
	default:
		return f.GetType()
	}
}

// GetFieldName returns the field name in snake_case format.
func (g RustGenerator) GetFieldName(f *model.Field) string {
	return strcase.ToSnake(f.Name)
}

// EncodeField encoding field
func (g RustGenerator) EncodeField(p *model.Packet, f *model.Field) string {
	parentName := strcase.ToCamel(p.Name)
	if _, ok := f.Attr.(*model.LengthFieldAttribute); ok {
		// auto calculate length field
		var b strings.Builder
		b.WriteString(fmt.Sprintf("let %s_pos = buf.len();\n", strcase.ToSnake(f.Name)))
		if g.config.LittleEndian {
			b.WriteString(fmt.Sprintf("buf.put_%s_le(0);\n", f.GetType()))
		} else {
			b.WriteString(fmt.Sprintf("buf.put_%s(0);\n", f.GetType()))
		}

		return b.String()
	}

	if csf, ok := f.Attr.(*model.CheckSumFieldAttribute); ok {
		var b strings.Builder
		b.WriteString(fmt.Sprintf("let val = CHECKSUM_SERVICE_CONTEXT.get(%s)\n", csf.CheckSumType))
		b.WriteString("    .and_then(|service| match service.calc(buf) {\n")
		b.WriteString(fmt.Sprintf("        Checksum::%s(v) => Some(v),\n", strings.ToUpper(f.GetType())))
		b.WriteString("        _ => None,\n")
		b.WriteString(fmt.Sprintf("        }).unwrap_or(self.%s);\n", strcase.ToSnake(f.Name)))
		b.WriteString(fmt.Sprintf("    buf.put_%s(val);\n", f.GetType()))
		return b.String()
	}

	name := strcase.ToSnake(f.Name)
	padding := g.GetPadding(f)
	if f.IsRepeat {
		switch c := f.Attr.(type) {
		case *model.FixedStringFieldAttribute:
			size := c.Length
			if g.config.LittleEndian {
				if !padding.IsDefault() {
					return fmt.Sprintf("put_fixed_string_list_with_pad_char_le::<%s>(buf, &self.%s, %d, %s, %t);", g.config.ListLenPrefixLenType, name, size, padding.PadChar, padding.PadLeft)
				}
				return fmt.Sprintf("put_fixed_string_list_le::<%s>(buf, &self.%s, %d);", g.config.ListLenPrefixLenType, name, size)
			}
			if !padding.IsDefault() {
				return fmt.Sprintf("put_fixed_string_list_with_pad_char::<%s>(buf, &self.%s, %d, %s, %t);", g.config.ListLenPrefixLenType, name, size, padding.PadChar, padding.PadLeft)
			}
			return fmt.Sprintf("put_fixed_string_list::<%s>(buf, &self.%s, %d);", g.config.ListLenPrefixLenType, name, size)
		case *model.DynamicStringFieldAttribute:
			if g.config.LittleEndian {
				return fmt.Sprintf("put_string_list_le::<%s,%s>(buf, &self.%s);", g.config.ListLenPrefixLenType, g.config.StringLenPrefixLenType, name)
			}
			return fmt.Sprintf("put_string_list::<%s,%s>(buf, &self.%s);", g.config.ListLenPrefixLenType, g.config.StringLenPrefixLenType, name)
		case *model.ObjectFieldAttribute:
			if g.config.LittleEndian {
				return fmt.Sprintf("put_object_list_le::<%s,%s>(buf, &self.%s);", f.GetType(), g.config.ListLenPrefixLenType, name)
			}
			return fmt.Sprintf("put_object_list::<%s,%s>(buf, &self.%s);", f.GetType(), g.config.ListLenPrefixLenType, name)

		}

		if f.GetType() == "char" {
			return fmt.Sprintf("put_char_list::<%s>(buf, &self.%s);", g.config.ListLenPrefixLenType, name)
		}
		if g.config.LittleEndian {
			return fmt.Sprintf("put_list_le::<%s,%s>(buf, &self.%s);", f.GetType(), g.config.ListLenPrefixLenType, name)
		}
		return fmt.Sprintf("put_list::<%s,%s>(buf, &self.%s);", f.GetType(), g.config.ListLenPrefixLenType, name)
	}

	if fs, ok := f.Attr.(*model.FixedStringFieldAttribute); ok {
		if !padding.IsDefault() {
			return fmt.Sprintf("put_char_array_with_pad_char(buf, &self.%s, %d, %s, %t);", name, fs.Length, padding.PadChar, padding.PadLeft)
		}
		return fmt.Sprintf("put_char_array(buf, &self.%s, %d);", name, fs.Length)
	}

	switch c := f.Attr.(type) {
	case *model.DynamicStringFieldAttribute:
		if g.config.LittleEndian {
			return fmt.Sprintf("put_%s_le::<%s>(buf, &self.%s);", f.GetType(), g.config.StringLenPrefixLenType, name)
		}
		return fmt.Sprintf("put_%s::<%s>(buf, &self.%s);", f.GetType(), g.config.StringLenPrefixLenType, name)

	case *model.MatchFieldAttribute:
		var b strings.Builder
		if _, ok := f.LenAttr.(*model.LengthFieldAttribute); ok {
			b.WriteString(fmt.Sprintf("let %s_start = buf.len();\n", strcase.ToSnake(f.Name)))
		}
		b.WriteString(g.EncoderMatchField(parentName, "buf", f, c))
		b.WriteString("\n")
		if _, ok := f.LenAttr.(*model.LengthFieldAttribute); ok {
			b.WriteString(fmt.Sprintf("let %s_end = buf.len();\n", strcase.ToSnake(f.Name)))
			typ := cppBasicTypeMap[p.LengthField.GetType()]
			if g.config.LittleEndian {
				b.WriteString(fmt.Sprintf("    LittleEndian::write_%s(&mut buf[%s_pos..%s_pos + %d], (%s_end - %s_start) as %s);\n",
					p.LengthField.GetType(), strcase.ToSnake(p.LengthField.Name), strcase.ToSnake(p.LengthField.Name),
					typ.Size, strcase.ToSnake(f.Name), strcase.ToSnake(f.Name), p.LengthField.GetType()))
			} else {
				b.WriteString(fmt.Sprintf("    BigEndian::write_%s(&mut buf[%s_pos..%s_pos + %d], (%s_end - %s_start) as %s);\n",
					p.LengthField.GetType(), strcase.ToSnake(p.LengthField.Name), strcase.ToSnake(p.LengthField.Name),
					typ.Size, strcase.ToSnake(f.Name), strcase.ToSnake(f.Name), p.LengthField.GetType()))
			}

		}

		return b.String()
	case *model.ObjectFieldAttribute:
		return fmt.Sprintf("self.%s.encode(buf);", g.GetFieldName(f))
	default:
		switch f.GetType() {
		case "char":
			return fmt.Sprintf("put_%s(buf, self.%s);", f.GetType(), name)
		case "u8", "i8":
			return fmt.Sprintf("buf.put_%s(self.%s);", f.GetType(), name)
		case "u16", "u32", "u64", "i16", "i32", "i64", "f32", "f64":
			if g.config.LittleEndian {
				return fmt.Sprintf("buf.put_%s_le(self.%s);", f.GetType(), name)
			}
			return fmt.Sprintf("buf.put_%s(self.%s);", f.GetType(), name)
		default:
			return fmt.Sprintf("// unknown type for encode: %s", f.GetType())
		}
	}

}

// EncoderMatchField encodes match field
func (g RustGenerator) EncoderMatchField(parentName string, bufName string, f *model.Field, mfa *model.MatchFieldAttribute) string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("match &self.%s {\n", g.GetFieldName(f)))
	pairs := make(map[string]struct{})
	for _, pair := range mfa.MatchPairs {
		if _, exists := pairs[pair.Value]; exists {
			continue
		}
		pairs[pair.Value] = struct{}{}
		b.WriteString(AddIndent4ln(fmt.Sprintf("%s%sEnum::%s(msg) => msg.encode(%s),", parentName, f.Name, pair.Value, bufName)))
	}
	b.WriteString("}")
	return b.String()
}

// DecodeField decoding field
func (g RustGenerator) DecodeField(parentName string, f *model.Field) string {
	name := strcase.ToSnake(f.Name)
	padding := g.GetPadding(f)
	if f.IsRepeat {
		switch c := f.Attr.(type) {
		case *model.FixedStringFieldAttribute:
			if g.config.LittleEndian {
				if !padding.IsDefault() {
					return fmt.Sprintf("let %s = get_fixed_string_list_trim_pad_char_le::<%s>(buf, %d, %s, %t)?;", name, g.config.ListLenPrefixLenType, c.Length, padding.PadChar, padding.PadLeft)
				}
				return fmt.Sprintf("let %s = get_fixed_string_list_le::<%s>(buf, %d)?;", name, g.config.ListLenPrefixLenType, c.Length)
			}
			if !padding.IsDefault() {
				return fmt.Sprintf("let %s = get_fixed_string_list_trim_pad_char::<%s>(buf, %d, %s, %t)?;", name, g.config.ListLenPrefixLenType, c.Length, padding.PadChar, padding.PadLeft)
			}
			return fmt.Sprintf("let %s = get_fixed_string_list::<%s>(buf, %d)?;", name, g.config.ListLenPrefixLenType, c.Length)

		case *model.DynamicStringFieldAttribute:
			if g.config.LittleEndian {
				return fmt.Sprintf("let %s = get_string_list_le::<%s,%s>(buf)?;", name, g.config.ListLenPrefixLenType, g.config.StringLenPrefixLenType)
			}
			return fmt.Sprintf("let %s = get_string_list::<%s,%s>(buf)?;", name, g.config.ListLenPrefixLenType, g.config.StringLenPrefixLenType)

		case *model.ObjectFieldAttribute:
			if g.config.LittleEndian {
				return fmt.Sprintf("let %s = get_object_list_le::<%s,%s>(buf)?;", name, f.GetType(), g.config.ListLenPrefixLenType)
			}
			return fmt.Sprintf("let %s = get_object_list::<%s,%s>(buf)?;", name, f.GetType(), g.config.ListLenPrefixLenType)

		}

		if f.GetType() == "char" {
			return fmt.Sprintf("let %s = get_char_list::<%s>(buf)?;", name, g.config.ListLenPrefixLenType)
		}
		if g.config.LittleEndian {
			return fmt.Sprintf("let %s = get_list_le::<%s,%s>(buf)?;", name, f.GetType(), g.config.ListLenPrefixLenType)
		}

		return fmt.Sprintf("let %s = get_list::<%s,%s>(buf)?;", name, f.GetType(), g.config.ListLenPrefixLenType)
	}

	switch c := f.Attr.(type) {
	case *model.FixedStringFieldAttribute:
		if !padding.IsDefault() {
			return fmt.Sprintf("let %s = get_char_array_trim_pad_char(buf, %d, %s, %t)?;", name, c.Length, padding.PadChar, padding.PadLeft)
		}
		return fmt.Sprintf("let %s = get_char_array(buf, %d)?;", name, c.Length)
	case *model.DynamicStringFieldAttribute:
		if g.config.LittleEndian {
			return fmt.Sprintf("let %s = get_%s_le::<%s>(buf)?;", name, f.GetType(), g.config.StringLenPrefixLenType)
		}
		return fmt.Sprintf("let %s = get_%s::<%s>(buf)?;", name, f.GetType(), g.config.StringLenPrefixLenType)
	case *model.MatchFieldAttribute:
		return g.DecodeMatchField(parentName, f, c)
	case *model.ObjectFieldAttribute:
		return fmt.Sprintf("let %s = %s::decode(buf)?;", g.GetFieldName(f), c.RefPacket.Name)
	}

	switch f.GetType() {
	case "char":
		return fmt.Sprintf("let %s = get_%s(buf)?;", name, f.GetType())
	case "u8", "i8":
		return fmt.Sprintf("let %s = buf.get_%s();", name, f.GetType())
	case "u16", "u32", "u64", "i16", "i32", "i64", "f32", "f64":
		if g.config.LittleEndian {
			return fmt.Sprintf("let %s = buf.get_%s_le();", name, f.GetType())
		}
		return fmt.Sprintf("let %s = buf.get_%s();", name, f.GetType())
	default:
		return fmt.Sprintf("// unknown type for decode: %s", f.GetType())
	}
}

// HasQuotes is string literal
func (g RustGenerator) HasQuotes(s string) bool {
	if len(s) < 2 {
		return false
	}
	first, last := s[0], s[len(s)-1]
	return (first == '"' && last == '"')
}

// DecodeMatchField decodes match field
func (g RustGenerator) DecodeMatchField(parentName string, f *model.Field, mfa *model.MatchFieldAttribute) string {
	var b strings.Builder
	matchKey := strcase.ToSnake(mfa.MatchKeyField.Name)
	if g.HasQuotes(mfa.MatchPairs[0].Key) {
		matchKey += ".as_str()"
	}
	b.WriteString(fmt.Sprintf("let %s = match %s {\n", strcase.ToSnake(f.Name), matchKey))
	var pairs = make(map[string]struct{})
	for _, pair := range mfa.MatchPairs {
		key := pair.Key
		if _, exists := pairs[key]; exists {
			continue
		}
		pairs[key] = struct{}{}
		b.WriteString(AddIndent4ln(fmt.Sprintf("%s => %s%sEnum::%s(%s::decode(buf)?),", key, parentName, f.Name, pair.Value, pair.Value)))
	}
	b.WriteString(AddIndent4ln("_ => return None,"))
	b.WriteString("};")
	return b.String()
}

// generateMatchFieldEnumCode to enum
func (g RustGenerator) generateMatchFieldEnumCode(packet *model.Packet) string {
	var b strings.Builder
	for _, f := range packet.Fields {
		if mf, ok := f.Attr.(*model.MatchFieldAttribute); ok {
			b.WriteString("#[derive(Debug, Clone, PartialEq)]")
			b.WriteString(fmt.Sprintf("pub enum %s%sEnum {\n", packet.Name, f.Name))
			matchValus := make(map[string]struct{})
			for _, pair := range mf.MatchPairs {
				if _, exists := matchValus[pair.Value]; exists {
					continue // Skip if already added
				}
				b.WriteString(fmt.Sprintf("    %s(%s),\n", pair.Value, pair.Value))
				matchValus[pair.Value] = struct{}{}
			}
			b.WriteString("}\n\n")
		}
	}
	return b.String()
}

func (g RustGenerator) generateUnitTestCode(pkt *model.Packet) string {
	var b strings.Builder

	b.WriteString(fmt.Sprintf("#[cfg(test)]\nmod %s_tests {\n", strcase.ToSnake(pkt.Name)))
	b.WriteString(AddIndent4ln("use super::*;"))
	b.WriteString(AddIndent4ln("use bytes::BytesMut;"))

	b.WriteString(g.generateUseCode(pkt) + "\n\n")

	b.WriteString(AddIndent4ln("#[test]"))
	b.WriteString(AddIndent4ln(fmt.Sprintf("fn test_%s_codec() {", strcase.ToSnake(pkt.Name))))

	// new instance
	b.WriteString(AddIndent4ln(AddIndent4(fmt.Sprintf("let mut original = %s {", strcase.ToCamel(pkt.Name)))))
	for _, f := range pkt.Fields {
		if mf, ok := f.Attr.(*model.MatchFieldAttribute); ok {
			if len(mf.MatchPairs) > 0 {
				key := mf.MatchPairs[0].Key
				if g.HasQuotes(key) {
					key = fmt.Sprintf("%s.to_string()", key)
				}
				b.WriteString(AddIndent4ln(AddIndent4(AddIndent4(fmt.Sprintf("%s: %s,", strcase.ToSnake(mf.MatchKeyField.Name), key)))))
				b.WriteString(AddIndent4ln(AddIndent4(AddIndent4(fmt.Sprintf("%s: %s,", g.GetFieldName(f), g.testValue(pkt.Name, f))))))
			}
			continue
		}
		if pkt.MatchFields[f.Name] != nil {
			continue
		}
		b.WriteString(AddIndent4ln(AddIndent4(AddIndent4(fmt.Sprintf("%s: %s,", g.GetFieldName(f), g.testValue(pkt.Name, f))))))
	}
	b.WriteString(AddIndent4ln(AddIndent4("};\n")))

	// encoding
	b.WriteString(AddIndent4ln(AddIndent4("let mut buf = BytesMut::new();")))
	b.WriteString(AddIndent4ln(AddIndent4("original.encode(&mut buf);")))
	b.WriteString(AddIndent4ln(AddIndent4("let mut bytes = buf.freeze();\n")))

	// decoding
	b.WriteString(AddIndent4ln(AddIndent4(fmt.Sprintf("let decoded = %s::decode(&mut bytes).unwrap();", strcase.ToCamel(pkt.Name)))))
	for _, f := range pkt.Fields {
		switch f.Attr.(type) {
		case *model.LengthFieldAttribute, *model.CheckSumFieldAttribute:
			b.WriteString(AddIndent4ln(AddIndent4(fmt.Sprintf("original.%s = decoded.%s;", strcase.ToSnake(f.Name), strcase.ToSnake(f.Name)))))
		}
	}
	// assertion
	b.WriteString(AddIndent4ln(AddIndent4("assert_eq!(original, decoded);")))
	b.WriteString(AddIndent4ln("}"))
	b.WriteString("}\n")

	return b.String()
}

// testValue gen test value for deferent field type
func (g RustGenerator) testValue(parentName string, f *model.Field) string {
	if f.IsRepeat {
		return g.testValueList(f)
	}

	return g.testValueSingle(parentName, f)
}

func (g RustGenerator) testValueList(f *model.Field) string {

	if fs, ok := f.Attr.(*model.FixedStringFieldAttribute); ok {
		return fmt.Sprintf("vec![\"a\".to_string(); %d]", fs.Length)
	}

	if val, ok := g.primitiveListValues()[f.GetType()]; ok {
		return val
	}

	return "vec![]"
}

func (g RustGenerator) testValueSingle(parentName string, f *model.Field) string {
	switch c := f.Attr.(type) {
	case *model.LengthFieldAttribute:
		return "0"
	case *model.MatchFieldAttribute:
		return g.testMatchValue(parentName, f, c)
	case *model.FixedStringFieldAttribute:
		return fmt.Sprintf("vec!['a'; %d].into_iter().collect::<String>()", c.Length)
	case *model.ObjectFieldAttribute:
		// If it's a nested object, we need to create a default instance
		var fieldValues []string
		for _, subField := range c.RefPacket.Fields {
			fieldValues = append(fieldValues, fmt.Sprintf("%s: %s", strcase.ToSnake(subField.Name), g.testValue(c.RefPacket.Name, subField)))
		}
		return fmt.Sprintf("%s{\n %s \n}", strcase.ToCamel(c.RefPacket.Name), strings.Join(fieldValues, ",\n"))
	default:
		// handle primitive
		if val, ok := g.primitiveSingleValues()[f.GetType()]; ok {
			return val
		}
		return "Default::default()"
	}

	// if p, ok := g.binModel.PacketsMap[f.GetType()]; ok {
	// 	// If it's a nested object, we need to create a default instance
	// 	var fieldValues []string
	// 	for _, subField := range p.Fields {
	// 		fieldValues = append(fieldValues, fmt.Sprintf("%s: %s", strcase.ToSnake(subField.Name), g.testValue(p.Name, subField)))
	// 	}
	// 	return fmt.Sprintf("%s{\n %s \n}", strcase.ToCamel(p.Name), strings.Join(fieldValues, ",\n"))
	// }

}

func (g RustGenerator) primitiveListValues() map[string]string {
	return map[string]string{
		"string": `vec!["example".to_string(), "test".to_string()]`,
		"char":   `vec!['a','b']`,
		"u8":     "vec![42,12]",
		"u16":    "vec![1234,4321]",
		"u32":    "vec![123456,654321]",
		"u64":    "vec![123456789,987654321]",
		"i8":     "vec![-42,-12]",
		"i16":    "vec![-1234,-4321]",
		"i32":    "vec![-123456,-654321]",
		"i64":    "vec![-123456789,-987654321]",
	}
}

func (g RustGenerator) primitiveSingleValues() map[string]string {
	return map[string]string{
		"string": `"example".to_string()`,
		"char":   `'a'`,
		"u8":     "42",
		"u16":    "1234",
		"u32":    "123456",
		"u64":    "123456789",
		"i8":     "-42",
		"i16":    "-1234",
		"i32":    "-123456",
		"i64":    "-123456789",
	}
}

func (g RustGenerator) testMatchValue(parentName string, f *model.Field, mf *model.MatchFieldAttribute) string {
	if len(mf.MatchPairs) == 0 {
		return fmt.Sprintf("%s%s::default()", parentName, mf.MatchKeyField.Name)
	}

	matchName := mf.MatchPairs[0].Value
	subPacket := g.binModel.PacketsMap[matchName]
	var innerFields []string
	for _, subField := range subPacket.Fields {
		innerFields = append(innerFields,
			fmt.Sprintf("%s: %s", strcase.ToSnake(subField.Name), g.testValue(parentName, subField)))
	}
	return fmt.Sprintf("%s%sEnum::%s(%s { \n %s \n })",
		parentName,
		f.Name,
		matchName,
		matchName,
		strings.Join(innerFields, ", \n "),
	)
}
