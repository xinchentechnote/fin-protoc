package parser

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/xinchentechnote/fin-protoc/internal/model"
)

// RustGenerator a rust code generator
type RustGenerator struct {
	config   *GeneratorConfig
	binModel *model.BinaryModel
}

// NewRustGenerator new
func NewRustGenerator(config *GeneratorConfig, binModel *model.BinaryModel) *RustGenerator {
	return &RustGenerator{
		config:   config,
		binModel: binModel,
	}
}

// Generate rust code
func (g RustGenerator) Generate(binModel *model.BinaryModel) (map[string][]byte, error) {
	output := make(map[string][]byte)
	for _, pkt := range binModel.PacketsMap {
		code := g.generateRustFileForPacket(&pkt)
		output[strcase.ToSnake(pkt.Name)+".rs"] = []byte(code)
	}
	output["lib.rs"] = []byte(g.generateLibCode())
	return output, nil
}

func (g RustGenerator) generateRustFileForPacket(pkt *model.Packet) string {
	var b strings.Builder

	b.WriteString("// Code generated by fin-protoc. DO NOT EDIT.\n")
	// Rust use statements
	b.WriteString("use binary_codec::*;\n")
	b.WriteString("use bytes::{Buf, BufMut, Bytes, BytesMut};\n\n")
	//
	b.WriteString(g.generateUseCode(pkt))
	b.WriteString("\n")
	b.WriteString(g.generateMatchFieldEnumCode(pkt))
	b.WriteString("\n")
	b.WriteString(g.generateStructCode(pkt))

	return b.String()
}

func (g RustGenerator) generateLibCode() string {
	var b strings.Builder
	for _, pkt := range g.binModel.PacketsMap {
		b.WriteString(fmt.Sprintf("pub mod %s;\n", strcase.ToSnake(pkt.Name)))
	}
	return b.String()
}

// GenerateUseCode generates use statements for match pairs in the packet.
func (g RustGenerator) generateUseCode(msg *model.Packet) string {
	var b strings.Builder
	usePackets := make(map[string]struct{})
	for _, f := range msg.Fields {
		if f.GetType() == "match" {
			for _, pair := range f.MatchPairs {
				if _, exists := usePackets[pair.Value]; exists {
					continue // Skip if already added
				}
				usePackets[pair.Value] = struct{}{}
			}
		} else {
			if _, exists := usePackets[f.Type]; exists {
				continue // Skip if already added
			}
			if _, exsits := g.binModel.PacketsMap[f.Type]; exsits {
				usePackets[f.Type] = struct{}{}
			}
		}
	}

	for key := range usePackets {
		b.WriteString(fmt.Sprintf("use crate::%s::*;\n", strcase.ToSnake(key)))
	}
	return b.String()
}

func (g RustGenerator) generateStructCode(pkt *model.Packet) string {
	var b strings.Builder
	for _, f := range pkt.Fields {
		if f.InerObject != nil {
			b.WriteString(g.generateStructCode(f.InerObject))
			b.WriteString("\n")
		}
	}
	b.WriteString("\n")
	// struct
	structName := strcase.ToCamel(pkt.Name)
	b.WriteString("#[derive(Debug, Clone, PartialEq)]\n")
	b.WriteString(fmt.Sprintf("pub struct %s {\n", structName))
	//struct fields
	for _, f := range pkt.Fields {
		if f.IsRepeat {
			b.WriteString(AddIndent4ln(fmt.Sprintf("pub %s: Vec<%s>,", GetFieldName(f), GetFieldType(structName, f))))
		} else {
			b.WriteString(AddIndent4ln(fmt.Sprintf("pub %s: %s,", GetFieldName(f), GetFieldType(structName, f))))
		}
	}
	b.WriteString("}\n\n")

	// impl BinaryCodec
	b.WriteString(fmt.Sprintf("impl BinaryCodec for %s {\n", structName))
	b.WriteString("\n")
	// encode()
	if len(pkt.Fields) == 0 {
		b.WriteString(AddIndent4ln("fn encode(&self, _buf: &mut BytesMut) {"))
	} else {
		b.WriteString(AddIndent4ln("fn encode(&self, buf: &mut BytesMut) {"))
	}
	for _, f := range pkt.Fields {
		b.WriteString(AddIndent4ln(AddIndent4(g.EncodeField(structName, f))))
	}
	b.WriteString(AddIndent4ln("}"))
	b.WriteString("\n")
	// decode()
	if len(pkt.Fields) == 0 {
		b.WriteString(AddIndent4ln(fmt.Sprintf("fn decode(_buf: &mut Bytes) -> Option<%s> {", structName)))
	} else {
		b.WriteString(AddIndent4ln(fmt.Sprintf("fn decode(buf: &mut Bytes) -> Option<%s> {", structName)))
	}
	for _, f := range pkt.Fields {
		b.WriteString(AddIndent4ln(AddIndent4(g.DecodeField(structName, f))))
	}
	b.WriteString(AddIndent4ln(AddIndent4("Some(Self {")))
	for _, f := range pkt.Fields {
		b.WriteString(AddIndent4ln(AddIndent4(AddIndent4(GetFieldName(f) + ","))))
	}
	b.WriteString(AddIndent4ln(AddIndent4("})")))
	b.WriteString(AddIndent4ln("}"))
	b.WriteString("}\n")
	b.WriteString("\n")

	b.WriteString(g.generateUnitTestCode(pkt))
	return b.String()
}

// GetFieldType convert field type for rust
func GetFieldType(parentName string, f model.Field) string {
	switch f.GetType() {
	case "string":
		return "String"
	case "match":
		return parentName + f.MatchType + "Enum"
	default:
		pattern := `^char\[(\d+)\]$`
		re := regexp.MustCompile(pattern)
		if re.MatchString(f.GetType()) {
			return "String"
		}
		return f.GetType()

	}
}

// GetFieldName returns the field name in snake_case format.
func GetFieldName(f model.Field) string {
	switch f.GetType() {
	case "match":
		return strcase.ToSnake(f.Name) + "_body"
	default:
		return strcase.ToSnake(f.Name)

	}
}

// EncodeField encoding field
func (g RustGenerator) EncodeField(parentName string, f model.Field) string {
	name := strcase.ToSnake(f.Name)
	if f.IsRepeat {
		if f.GetType() == "string" {
			return fmt.Sprintf("put_string_list::<%s,%s>(buf, &self.%s);", g.config.ListLenPrefixLenType, g.config.StringLenPrefixLenType, name)
		}
		size, ok := ParseCharArrayType(f.GetType())
		if ok {
			return fmt.Sprintf("put_fixed_string_list::<%s>(buf, &self.%s, %s);", g.config.ListLenPrefixLenType, name, size)
		}
		return fmt.Sprintf("put_list::<%s,%s>(buf, &self.%s);", f.GetType(), g.config.ListLenPrefixLenType, name)
	}
	switch f.GetType() {
	case "string":
		return fmt.Sprintf("put_%s(buf, &self.%s);", f.GetType(), name)
	case "char":
		return fmt.Sprintf("put_%s(buf, self.%s);", f.GetType(), name)
	case "u8", "u16", "u32", "u64", "i8", "i16", "i32", "i64":
		return fmt.Sprintf("buf.put_%s(self.%s);", f.GetType(), name)
	case "match":
		return EncoderMatchField(parentName, f)
	default:
		size, ok := ParseCharArrayType(f.GetType())
		if ok {
			return fmt.Sprintf("put_char_array(buf, &self.%s, %s);", name, size)
		}
		if f.InerObject != nil {
			// If it's a nested object, we need to encode it
			return fmt.Sprintf("self.%s.encode(buf);", GetFieldName(f))

		}
		return fmt.Sprintf("// unknown type for encode: %s", f.GetType())
	}
}

// EncoderMatchField encodes match field
func EncoderMatchField(parentName string, f model.Field) string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("match &self.%s {\n", GetFieldName(f)))
	pairs := make(map[string]struct{})
	for _, pair := range f.MatchPairs {
		if _, exists := pairs[pair.Value]; exists {
			continue
		}
		pairs[pair.Value] = struct{}{}
		b.WriteString(AddIndent4ln(fmt.Sprintf("%s%sEnum::%s(msg) => msg.encode(buf),", parentName, f.MatchType, pair.Value)))
	}
	b.WriteString("}")
	return b.String()
}

// DecodeField decoding field
func (g RustGenerator) DecodeField(parentName string, f model.Field) string {
	name := strcase.ToSnake(f.Name)
	if f.IsRepeat {
		if f.GetType() == "string" {
			return fmt.Sprintf("let %s = get_string_list::<%s,%s>(buf)?;", name, g.config.ListLenPrefixLenType, g.config.StringLenPrefixLenType)
		}
		size, ok := ParseCharArrayType(f.GetType())
		if ok {
			return fmt.Sprintf("let %s = get_fixed_string_list::<%s>(buf, %s)?;", name, g.config.ListLenPrefixLenType, size)
		}
		return fmt.Sprintf("let %s = get_list::<%s,%s>(buf)?;", name, f.GetType(), g.config.ListLenPrefixLenType)
	}
	switch f.GetType() {
	case "string", "char":
		return fmt.Sprintf("let %s = get_%s(buf)?;", name, f.GetType())
	case "u8", "u16", "u32", "u64", "i8", "i16", "i32", "i64":
		return fmt.Sprintf("let %s = buf.get_%s();", name, f.GetType())
	case "match":
		return DecodeMatchField(parentName, f)
	default:
		pattern := `^char\[(\d+)\]$`
		re := regexp.MustCompile(pattern)
		matches := re.FindStringSubmatch(f.GetType())
		if len(matches) == 2 {
			size := matches[1]
			return fmt.Sprintf("let %s = get_char_array(buf, %s)?;", name, size)
		}
		if f.InerObject != nil {
			// If it's a nested object, we need to decode it
			return fmt.Sprintf("let %s = %s::decode(buf)?;", GetFieldName(f), f.InerObject.Name)
		}
		return fmt.Sprintf("// unknown type for decode: %s", f.GetType())
	}
}

// HasQuotes is string literal
func HasQuotes(s string) bool {
	if len(s) < 2 {
		return false
	}
	first, last := s[0], s[len(s)-1]
	return (first == '"' && last == '"')
}

// DecodeMatchField decodes match field
func DecodeMatchField(parentName string, f model.Field) string {
	var b strings.Builder
	matchName := strcase.ToSnake(f.Name)
	if HasQuotes(f.MatchPairs[0].Key) {
		matchName += ".as_str()"
	}
	b.WriteString(fmt.Sprintf("let %s_body = match %s {\n", strcase.ToSnake(f.Name), matchName))
	var pairs = make(map[string]struct{})
	for _, pair := range f.MatchPairs {
		key := pair.Key
		if _, exists := pairs[key]; exists {
			continue
		}
		pairs[key] = struct{}{}
		b.WriteString(AddIndent4ln(fmt.Sprintf("%s => %s%sEnum::%s(%s::decode(buf)?),", key, parentName, f.MatchType, pair.Value, pair.Value)))
	}
	b.WriteString(AddIndent4ln("_ => return None,"))
	b.WriteString("};")
	return b.String()
}

// generateMatchFieldEnumCode to enum
func (g RustGenerator) generateMatchFieldEnumCode(packet *model.Packet) string {
	var b strings.Builder
	for _, f := range packet.Fields {
		if f.GetType() == "match" {
			b.WriteString("#[derive(Debug, Clone, PartialEq)]")
			b.WriteString(fmt.Sprintf("pub enum %s%sEnum {\n", packet.Name, f.MatchType))
			matchValus := make(map[string]struct{})
			for _, pair := range f.MatchPairs {
				if _, exists := matchValus[pair.Value]; exists {
					continue // Skip if already added
				}
				b.WriteString(fmt.Sprintf("    %s(%s),\n", pair.Value, pair.Value))
				matchValus[pair.Value] = struct{}{}
			}
			b.WriteString("}\n\n")
		}
	}
	return b.String()
}

func (g RustGenerator) generateUnitTestCode(pkt *model.Packet) string {
	var b strings.Builder

	b.WriteString(fmt.Sprintf("#[cfg(test)]\nmod %s_tests {\n", strcase.ToSnake(pkt.Name)))
	b.WriteString(AddIndent4ln("use super::*;"))
	b.WriteString(AddIndent4ln("use bytes::BytesMut;"))

	b.WriteString(g.generateUseCode(pkt) + "\n\n")

	b.WriteString(AddIndent4ln("#[test]"))
	b.WriteString(AddIndent4ln(fmt.Sprintf("fn test_%s_codec() {", strcase.ToSnake(pkt.Name))))

	// new instance
	b.WriteString(AddIndent4ln(AddIndent4(fmt.Sprintf("let original = %s {", strcase.ToCamel(pkt.Name)))))
	for _, f := range pkt.Fields {
		if pkt.MatchFields[f.Name] != nil {
			if len(f.MatchPairs) > 0 {
				key := f.MatchPairs[0].Key
				if HasQuotes(key) {
					key = fmt.Sprintf("%s.to_string()", key)
				}
				b.WriteString(AddIndent4ln(AddIndent4(AddIndent4(fmt.Sprintf("%s: %s,", strcase.ToSnake(f.Name), key)))))
				b.WriteString(AddIndent4ln(AddIndent4(AddIndent4(fmt.Sprintf("%s: %s,", GetFieldName(f), g.testValue(pkt.Name, f))))))
			}
			continue
		}
		b.WriteString(AddIndent4ln(AddIndent4(AddIndent4(fmt.Sprintf("%s: %s,", GetFieldName(f), g.testValue(pkt.Name, f))))))
	}
	b.WriteString(AddIndent4ln(AddIndent4("};\n")))

	// encoding
	b.WriteString(AddIndent4ln(AddIndent4("let mut buf = BytesMut::new();")))
	b.WriteString(AddIndent4ln(AddIndent4("original.encode(&mut buf);")))
	b.WriteString(AddIndent4ln(AddIndent4("let mut bytes = buf.freeze();\n")))

	// decoding
	b.WriteString(AddIndent4ln(AddIndent4(fmt.Sprintf("let decoded = %s::decode(&mut bytes).unwrap();", strcase.ToCamel(pkt.Name)))))

	// assertion
	b.WriteString(AddIndent4ln(AddIndent4("assert_eq!(original, decoded);")))
	b.WriteString(AddIndent4ln("}"))
	b.WriteString("}\n")

	return b.String()
}

// testValue gen test value for deferent field type
func (g RustGenerator) testValue(parentName string, f model.Field) string {
	if f.IsRepeat {
		return testValueList(f.GetType())
	}

	return g.testValueSingle(parentName, f)
}

func testValueList(typ string) string {
	if val, ok := primitiveListValues()[typ]; ok {
		return val
	}
	size, ok := ParseCharArrayType(typ)
	if ok {
		return fmt.Sprintf("vec![\"a\".to_string(); %s]", size)
	}
	return "vec![]"
}

func (g RustGenerator) testValueSingle(parentName string, f model.Field) string {
	typ := f.GetType()

	// handle match
	if typ == "match" {
		return g.testMatchValue(parentName, f)
	}

	// handle char[n]
	size, ok := ParseCharArrayType(f.GetType())
	if ok {
		return fmt.Sprintf("vec!['a'; %s].into_iter().collect::<String>()", size)
	}

	// handle primitive
	if val, ok := primitiveSingleValues()[typ]; ok {
		return val
	}

	if f.InerObject != nil {
		// If it's a nested object, we need to create a default instance
		var fieldValues []string
		for _, subField := range f.InerObject.Fields {
			fieldValues = append(fieldValues, fmt.Sprintf("%s: %s", strcase.ToSnake(subField.Name), g.testValue(f.InerObject.Name, subField)))
		}
		return fmt.Sprintf("%s{\n %s \n}", strcase.ToCamel(f.InerObject.Name), strings.Join(fieldValues, ",\n"))
	}

	return "Default::default()"
}

func primitiveListValues() map[string]string {
	return map[string]string{
		"string": `vec!["example".to_string(), "test".to_string()]`,
		"char":   `vec!['a','b']`,
		"u8":     "vec![42,12]",
		"u16":    "vec![1234,4321]",
		"u32":    "vec![123456,654321]",
		"u64":    "vec![123456789,987654321]",
		"i8":     "vec![-42,-12]",
		"i16":    "vec![-1234,-4321]",
		"i32":    "vec![-123456,-654321]",
		"i64":    "vec![-123456789,-987654321]",
	}
}

func primitiveSingleValues() map[string]string {
	return map[string]string{
		"string": `"example".to_string()`,
		"char":   `'a'`,
		"u8":     "42",
		"u16":    "1234",
		"u32":    "123456",
		"u64":    "123456789",
		"i8":     "-42",
		"i16":    "-1234",
		"i32":    "-123456",
		"i64":    "-123456789",
	}
}

func (g RustGenerator) testMatchValue(parentName string, f model.Field) string {
	if len(f.MatchPairs) == 0 {
		return fmt.Sprintf("%s%s::default()", parentName, f.MatchType)
	}

	matchName := f.MatchPairs[0].Value
	subPacket := g.binModel.PacketsMap[matchName]
	var innerFields []string
	for _, subField := range subPacket.Fields {
		innerFields = append(innerFields,
			fmt.Sprintf("%s: %s", strcase.ToSnake(subField.Name), g.testValue(parentName, subField)))
	}
	return fmt.Sprintf("%s%sEnum::%s(%s { \n %s \n })",
		parentName,
		f.MatchType,
		matchName,
		matchName,
		strings.Join(innerFields, ", \n "),
	)
}
