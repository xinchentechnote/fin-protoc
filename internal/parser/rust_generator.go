package parser

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/xinchentechnote/fin-protoc/internal/model"
)

// RustGenerator gen rust code
type RustGenerator struct {
	Config  *GeneratorConfig
	Packets map[string]model.Packet // Store packets by name
}

// GenerateCode code for packet
func (g RustGenerator) GenerateCode(msg model.Packet) string {
	var b strings.Builder

	// Rust use statements
	b.WriteString("// Code generated by fin-protoc. DO NOT EDIT.\n")
	b.WriteString("use binary_codec::*;\n")
	b.WriteString("use bytes::{Buf, BufMut, Bytes, BytesMut};\n\n")

	b.WriteString(g.GenerateUseCode(msg))
	b.WriteString("\n")
	b.WriteString(g.GenerateStructCode(msg))
	return b.String()
}

// GenerateStructCode generates Rust code for a struct based on the provided packet model.
func (g RustGenerator) GenerateStructCode(msg model.Packet) string {
	var b strings.Builder
	b.WriteString(g.GenerateMatchFieldEnumCode(msg))
	b.WriteString("\n")
	for _, f := range msg.Fields {
		if f.InerObject != nil {
			b.WriteString(g.GenerateStructCode(*f.InerObject))
			b.WriteString("\n")
		}
	}
	b.WriteString("\n")
	// struct
	structName := toRustStructName(msg.Name)
	b.WriteString("#[derive(Debug, Clone, PartialEq)]\n")
	b.WriteString(fmt.Sprintf("pub struct %s {\n", structName))
	for _, f := range msg.Fields {
		if f.IsRepeat {
			b.WriteString(fmt.Sprintf("    pub %s: Vec<%s>,\n", GetFieldName(f), GetFieldType(structName, f)))
		} else {
			b.WriteString(fmt.Sprintf("    pub %s: %s,\n", GetFieldName(f), GetFieldType(structName, f)))
		}
	}
	b.WriteString("}\n\n")

	// impl BinaryCodec
	b.WriteString(fmt.Sprintf("impl BinaryCodec for %s {\n", structName))

	// encode()
	if len(msg.Fields) == 0 {
		b.WriteString("    fn encode(&self, _buf: &mut BytesMut) {\n")
	} else {
		b.WriteString("    fn encode(&self, buf: &mut BytesMut) {\n")
	}
	for _, f := range msg.Fields {
		b.WriteString(fmt.Sprintf("        %s\n", g.EncodeField(structName, f)))
	}
	b.WriteString("    }\n\n")

	// decode()
	if len(msg.Fields) == 0 {
		b.WriteString(fmt.Sprintf("    fn decode(_buf: &mut Bytes) -> Option<%s> {\n", structName))
	} else {
		b.WriteString(fmt.Sprintf("    fn decode(buf: &mut Bytes) -> Option<%s> {\n", structName))
	}
	for _, f := range msg.Fields {
		b.WriteString(fmt.Sprintf("        %s\n", g.DecodeField(structName, f)))
	}
	b.WriteString("        Some(Self {\n")
	for _, f := range msg.Fields {
		b.WriteString(fmt.Sprintf("            %s,\n", GetFieldName(f)))
	}
	b.WriteString("        })\n")
	b.WriteString("    }\n")
	b.WriteString("}\n")
	b.WriteString("\n")
	b.WriteString(g.GenerateTestCode(msg))
	return b.String()
}

// GenerateUseCode generates use statements for match pairs in the packet.
func (g RustGenerator) GenerateUseCode(msg model.Packet) string {
	var b strings.Builder
	usePackets := make(map[string]struct{})
	for _, f := range msg.Fields {
		if f.GetType() == "match" {
			for _, pair := range f.MatchPairs {
				if _, exists := usePackets[pair.Value]; exists {
					continue // Skip if already added
				}

				usePackets[pair.Value] = struct{}{}
			}
		} else {
			if _, exists := usePackets[f.Type]; exists {
				continue // Skip if already added
			}
			if _, exsits := g.Packets[f.Type]; exsits {
				usePackets[f.Type] = struct{}{}
			}
		}
	}

	for key := range usePackets {
		b.WriteString(fmt.Sprintf("use crate::%s::*;\n", toSnake(key)))
	}
	return b.String()
}

// assistant functions
// toSnake converts a CamelCase or PascalCase name to snake_case.
func toSnake(name string) string {
	return strcase.ToSnake(name)
}

// toRustStructName converts a name to CamelCase for Rust struct naming conventions.
func toRustStructName(name string) string {
	return strcase.ToCamel(name) // Rust structs ç”¨ CamelCase
}

// GetFieldType convert field type for rust
func GetFieldType(parentName string, f model.Field) string {
	switch f.GetType() {
	case "string":
		return "String"
	case "match":
		return parentName + f.MatchType + "Enum"
	default:
		pattern := `^char\[(\d+)\]$`
		re := regexp.MustCompile(pattern)
		if re.MatchString(f.GetType()) {
			return "String"
		}
		return f.GetType()

	}
}

// GetFieldName returns the field name in snake_case format.
func GetFieldName(f model.Field) string {
	switch f.GetType() {
	case "match":
		return toSnake(f.Name) + "_body"
	default:
		return toSnake(f.Name)

	}
}

// EncodeField encoding field
func (g RustGenerator) EncodeField(parentName string, f model.Field) string {
	name := toSnake(f.Name)
	if f.IsRepeat {
		if f.GetType() == "string" {
			return fmt.Sprintf("put_string_list::<%s,%s>(buf, &self.%s);", g.Config.ListLenPrefixLenType, g.Config.StringLenPrefixLenType, name)
		}
		size, ok := ParseCharArrayType(f.GetType())
		if ok {
			return fmt.Sprintf("put_fixed_string_list::<%s>(buf, &self.%s, %s);", g.Config.ListLenPrefixLenType, name, size)
		}
		return fmt.Sprintf("put_list::<%s,%s>(buf, &self.%s);", f.GetType(), g.Config.ListLenPrefixLenType, name)
	}
	switch f.GetType() {
	case "string":
		return fmt.Sprintf("put_%s(buf, &self.%s);", f.GetType(), name)
	case "char":
		return fmt.Sprintf("put_%s(buf, self.%s);", f.GetType(), name)
	case "u8", "u16", "u32", "u64", "i8", "i16", "i32", "i64":
		return fmt.Sprintf("buf.put_%s(self.%s);", f.GetType(), name)
	case "match":
		return EncoderMatchField(parentName, f)
	default:
		size, ok := ParseCharArrayType(f.GetType())
		if ok {
			return fmt.Sprintf("put_char_array(buf, &self.%s, %s);", name, size)
		}
		if f.InerObject != nil {
			// If it's a nested object, we need to encode it
			return fmt.Sprintf("self.%s.encode(buf);", GetFieldName(f))

		}
		return fmt.Sprintf("// unknown type for encode: %s", f.GetType())
	}
}

// EncoderMatchField encodes match field
func EncoderMatchField(parentName string, f model.Field) string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("match &self.%s {\n", GetFieldName(f)))
	pairs := make(map[string]struct{})
	for _, pair := range f.MatchPairs {
		if _, exists := pairs[pair.Value]; exists {
			continue
		}
		pairs[pair.Value] = struct{}{}
		b.WriteString(fmt.Sprintf("  %s%sEnum::%s(msg) => msg.encode(buf),\n", parentName, f.MatchType, pair.Value))
	}
	b.WriteString("}")
	return b.String()
}

// DecodeField decoding field
func (g RustGenerator) DecodeField(parentName string, f model.Field) string {
	name := toSnake(f.Name)
	if f.IsRepeat {
		if f.GetType() == "string" {
			return fmt.Sprintf("let %s = get_string_list::<%s,%s>(buf)?;", name, g.Config.ListLenPrefixLenType, g.Config.StringLenPrefixLenType)
		}
		size, ok := ParseCharArrayType(f.GetType())
		if ok {
			return fmt.Sprintf("let %s = get_fixed_string_list::<%s>(buf, %s)?;", name, g.Config.ListLenPrefixLenType, size)
		}
		return fmt.Sprintf("let %s = get_list::<%s,%s>(buf)?;", name, f.GetType(), g.Config.ListLenPrefixLenType)
	}
	switch f.GetType() {
	case "string", "char":
		return fmt.Sprintf("let %s = get_%s(buf)?;", name, f.GetType())
	case "u8", "u16", "u32", "u64", "i8", "i16", "i32", "i64":
		return fmt.Sprintf("let %s = buf.get_%s();", name, f.GetType())
	case "match":
		return DecodeMatchField(parentName, f)
	default:
		pattern := `^char\[(\d+)\]$`
		re := regexp.MustCompile(pattern)
		matches := re.FindStringSubmatch(f.GetType())
		if len(matches) == 2 {
			size := matches[1]
			return fmt.Sprintf("let %s = get_char_array(buf, %s)?;", name, size)
		}
		if f.InerObject != nil {
			// If it's a nested object, we need to decode it
			return fmt.Sprintf("let %s = %s::decode(buf)?;", GetFieldName(f), f.InerObject.Name)
		}
		return fmt.Sprintf("// unknown type for decode: %s", f.GetType())
	}
}

// HasQuotes is string literal
func HasQuotes(s string) bool {
	if len(s) < 2 {
		return false
	}
	first, last := s[0], s[len(s)-1]
	return (first == '"' && last == '"')
}

// DecodeMatchField decodes match field
func DecodeMatchField(parentName string, f model.Field) string {
	var b strings.Builder
	matchName := toSnake(f.Name)
	if HasQuotes(f.MatchPairs[0].Key) {
		matchName += ".as_str()"
	}
	b.WriteString(fmt.Sprintf("let %s_body = match %s {\n", toSnake(f.Name), matchName))
	var pairs = make(map[string]struct{})
	for _, pair := range f.MatchPairs {
		key := pair.Key
		if _, exists := pairs[key]; exists {
			continue
		}
		pairs[key] = struct{}{}
		b.WriteString(fmt.Sprintf("  %s => %s%sEnum::%s(%s::decode(buf)?),\n", key, parentName, f.MatchType, pair.Value, pair.Value))
	}
	b.WriteString(" _ => return None,\n")
	b.WriteString("};")
	return b.String()
}

// FileExtension rust file extension
func (RustGenerator) FileExtension() string {
	return ".rs"
}

// GenerateMatchFieldEnumCode to enum
func (g RustGenerator) GenerateMatchFieldEnumCode(packet model.Packet) string {
	var b strings.Builder
	for _, f := range packet.Fields {
		if f.GetType() == "match" {
			b.WriteString("#[derive(Debug, Clone, PartialEq)]")
			b.WriteString(fmt.Sprintf("pub enum %s%sEnum {\n", packet.Name, f.MatchType))
			matchValus := make(map[string]struct{})
			for _, pair := range f.MatchPairs {
				if _, exists := matchValus[pair.Value]; exists {
					continue // Skip if already added
				}
				b.WriteString(fmt.Sprintf("    %s(%s),\n", pair.Value, pair.Value))
				matchValus[pair.Value] = struct{}{}
			}
			b.WriteString("}\n\n")
		}
	}
	return b.String()
}

// GenerateTestCode gen unit test code
func (g RustGenerator) GenerateTestCode(packet model.Packet) string {
	var b strings.Builder

	structName := toRustStructName(packet.Name)
	instanceName := strcase.ToSnake(packet.Name)

	b.WriteString(fmt.Sprintf("#[cfg(test)]\nmod %s_tests {\n", instanceName))
	b.WriteString("    use super::*;\n")
	b.WriteString("    use bytes::BytesMut;\n")

	b.WriteString(g.GenerateUseCode(packet) + "\n\n")

	b.WriteString("    #[test]\n")
	b.WriteString(fmt.Sprintf("    fn test_%s_codec() {\n", instanceName))

	// new instance
	b.WriteString(fmt.Sprintf("        let original = %s {\n", structName))
	for _, f := range packet.Fields {
		if packet.MatchFields[f.Name] != nil {
			if len(f.MatchPairs) > 0 {
				key := f.MatchPairs[0].Key
				if HasQuotes(key) {
					key = fmt.Sprintf("%s.to_string()", key)
				}
				b.WriteString(fmt.Sprintf("            %s: %s,\n", toSnake(f.Name), key))
				b.WriteString(fmt.Sprintf("            %s: %s,\n", GetFieldName(f), g.TestValue(packet.Name, f)))
			}
			continue
		}
		b.WriteString(fmt.Sprintf("            %s: %s,\n", GetFieldName(f), g.TestValue(packet.Name, f)))
	}
	b.WriteString("        };\n\n")

	// encoding
	b.WriteString("        let mut buf = BytesMut::new();\n")
	b.WriteString("        original.encode(&mut buf);\n")
	b.WriteString("        let mut bytes = buf.freeze();\n\n")

	// decoding
	b.WriteString(fmt.Sprintf("        let decoded = %s::decode(&mut bytes).unwrap();\n\n", structName))

	// assertion
	b.WriteString("        assert_eq!(original, decoded);\n")
	b.WriteString("    }\n")
	b.WriteString("}\n")

	return b.String()
}

// TestValue gen test value for deferent field type
func (g RustGenerator) TestValue(parentName string, f model.Field) string {
	if f.IsRepeat {
		return testValueList(f.GetType())
	}

	return g.testValueSingle(parentName, f)
}

func testValueList(typ string) string {
	if val, ok := primitiveListValues()[typ]; ok {
		return val
	}
	size, ok := ParseCharArrayType(typ)
	if ok {
		return fmt.Sprintf("vec![\"a\".to_string(); %s]", size)
	}
	return "vec![]"
}

func (g RustGenerator) testValueSingle(parentName string, f model.Field) string {
	typ := f.GetType()

	// handle match
	if typ == "match" {
		return g.testMatchValue(parentName, f)
	}

	// handle char[n]
	size, ok := ParseCharArrayType(f.GetType())
	if ok {
		return fmt.Sprintf("vec!['a'; %s].into_iter().collect::<String>()", size)
	}

	// handle primitive
	if val, ok := primitiveSingleValues()[typ]; ok {
		return val
	}

	if f.InerObject != nil {
		// If it's a nested object, we need to create a default instance
		var fieldValues []string
		for _, subField := range f.InerObject.Fields {
			fieldValues = append(fieldValues, fmt.Sprintf("%s: %s", toSnake(subField.Name), g.TestValue(f.InerObject.Name, subField)))
		}
		return fmt.Sprintf("%s{\n %s \n}", toRustStructName(f.InerObject.Name), strings.Join(fieldValues, ",\n"))
	}

	return "Default::default()"
}

func primitiveListValues() map[string]string {
	return map[string]string{
		"string": `vec!["example".to_string(), "test".to_string()]`,
		"char":   `vec!['a','b']`,
		"u8":     "vec![42,12]",
		"u16":    "vec![1234,4321]",
		"u32":    "vec![123456,654321]",
		"u64":    "vec![123456789,987654321]",
		"i8":     "vec![-42,-12]",
		"i16":    "vec![-1234,-4321]",
		"i32":    "vec![-123456,-654321]",
		"i64":    "vec![-123456789,-987654321]",
	}
}

func primitiveSingleValues() map[string]string {
	return map[string]string{
		"string": `"example".to_string()`,
		"char":   `'a'`,
		"u8":     "42",
		"u16":    "1234",
		"u32":    "123456",
		"u64":    "123456789",
		"i8":     "-42",
		"i16":    "-1234",
		"i32":    "-123456",
		"i64":    "-123456789",
	}
}

func (g RustGenerator) testMatchValue(parentName string, f model.Field) string {
	if len(f.MatchPairs) == 0 {
		return fmt.Sprintf("%s%s::default()", parentName, f.MatchType)
	}

	matchName := f.MatchPairs[0].Value
	subPacket := g.Packets[matchName]
	var innerFields []string
	for _, subField := range subPacket.Fields {
		innerFields = append(innerFields,
			fmt.Sprintf("%s: %s", toSnake(subField.Name), g.TestValue(parentName, subField)))
	}
	return fmt.Sprintf("%s%sEnum::%s(%s { \n %s \n })",
		parentName,
		f.MatchType,
		matchName,
		matchName,
		strings.Join(innerFields, ", \n "),
	)
}
