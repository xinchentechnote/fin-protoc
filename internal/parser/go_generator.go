package parser

import (
	"fmt"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/xinchentechnote/fin-protoc/internal/model"
)

// GoType represents a Go type with its properties
type GoType struct {
	Name      string
	BasicType string
	TestValue string
	Size      uint32
}

var goBasicTypeMap = map[string]GoType{
	"i8":  {"i8", "int8", "1", 1},
	"i16": {"i16", "int16", "2", 2},
	"i32": {"i32", "int32", "4", 4},
	"i64": {"i64", "int64", "8", 8},
	"u8":  {"u8", "uint8", "1", 1},
	"u16": {"u16", "uint16", "2", 2},
	"u32": {"u32", "uint32", "4", 4},
	"u64": {"u64", "uint64", "8", 8},
	"f32": {"f32", "float32", "4", 4},
	"f64": {"f64", "float64", "8", 8},
}

// GoGenerator a go code generator
type GoGenerator struct {
	binModel *model.BinaryModel
}

// NewGoGenerator new
func NewGoGenerator(binModel *model.BinaryModel) *GoGenerator {
	return &GoGenerator{
		binModel: binModel,
	}
}

// GetConfig get Configuration
func (g GoGenerator) GetConfig() *model.Configuration {
	return g.binModel.Config
}

// Generate go code
func (g GoGenerator) Generate(binModel *model.BinaryModel) (map[string][]byte, error) {
	output := make(map[string][]byte)
	for _, pkt := range binModel.PacketsMap {
		code := g.generateGoFileForPacket(pkt, false)
		output[strcase.ToSnake(pkt.Name)+".go"] = []byte(code)
		code = g.generateGoTestFileForPacket(pkt, false)
		output[strcase.ToSnake(pkt.Name)+"_test.go"] = []byte(code)
	}
	return output, nil
}

func (g GoGenerator) generateGoFileForPacket(p *model.Packet, isIner bool) string {
	var b strings.Builder
	if !isIner {
		b.WriteString("// Code generated by fin-protoc. DO NOT EDIT.\n")
		b.WriteString(fmt.Sprintf("package %s", g.GetConfig().GoPackage))
		b.WriteString("\n\n")
		b.WriteString(`import (
		"bytes"
		"fmt"
		"encoding/binary"
	
		"github.com/xinchentechnote/fin-proto-go/codec"
	)`)
		b.WriteString("\n\n")
	}

	// gen init
	b.WriteString("func init() {\n")
	for _, f := range p.Fields {
		if mf, ok := f.Attr.(*model.MatchFieldAttribute); ok {
			b.WriteString(g.generateInit(p, mf))
		}
	}
	b.WriteString("}\n")
	b.WriteString("\n")

	// gen MessageFactory
	for _, f := range p.Fields {
		if mf, ok := f.Attr.(*model.MatchFieldAttribute); ok {
			b.WriteString(g.generateMessageFactory(p, mf))
		}
	}

	for _, f := range p.Fields {
		if of, ok := f.Attr.(*model.ObjectFieldAttribute); ok && of.IsIner {
			b.WriteString(g.generateGoFileForPacket(of.RefPacket, true))
		}
	}

	b.WriteString(g.generateStructCode(p))
	b.WriteString("\n\n")
	b.WriteString(g.generateEncodingCode(p))
	b.WriteString("\n\n")
	b.WriteString(g.generateDecodingCode(p))
	b.WriteString("\n\n")

	return b.String()
}

func (g GoGenerator) generateInit(p *model.Packet, mf *model.MatchFieldAttribute) string {
	var b strings.Builder
	for _, pair := range mf.MatchPairs {
		b.WriteString(fmt.Sprintf("Registry%s%sFactory(%s, func() codec.BinaryCodec {return &%s{}})\n", strcase.ToCamel(p.Name), strcase.ToCamel(mf.MatchKeyField.Name), pair.Key, pair.Value))
	}
	return b.String()
}

func (g GoGenerator) generateMessageFactory(p *model.Packet, mfa *model.MatchFieldAttribute) string {
	typ := mfa.MatchKeyField.GetType()
	if t, ok := goBasicTypeMap[typ]; ok {
		typ = t.BasicType
	}
	var b strings.Builder
	packageNameLowerCamel := strcase.ToLowerCamel(p.Name)
	packageNameCamel := strcase.ToCamel(p.Name)
	matchKeyLowerCamel := strcase.ToLowerCamel(mfa.MatchKeyField.Name)
	matchKeyCamel := strcase.ToCamel(mfa.MatchKeyField.Name)
	b.WriteString(fmt.Sprintf("var %s%sFactoryCache = map[%s]func() codec.BinaryCodec{}\n", packageNameLowerCamel, matchKeyCamel, typ))
	b.WriteString("\n")
	//
	b.WriteString(fmt.Sprintf("func Registry%s%sFactory(%s %s,factory func() codec.BinaryCodec) {\n", packageNameCamel, matchKeyCamel, matchKeyLowerCamel, typ))
	b.WriteString(fmt.Sprintf("    %s%sFactoryCache[%s] = factory\n", packageNameLowerCamel, matchKeyCamel, matchKeyLowerCamel))
	b.WriteString("}\n")
	//
	b.WriteString("\n")
	b.WriteString(fmt.Sprintf("func New%sMessageBy%s(key %s) (codec.BinaryCodec, error) {\n", packageNameCamel, matchKeyCamel, typ))
	b.WriteString(fmt.Sprintf("    if factory, ok := %s%sFactoryCache[key]; ok{\n", packageNameLowerCamel, matchKeyCamel))
	b.WriteString("        return factory(),nil\n")
	b.WriteString("    }\n")
	b.WriteString("    return nil, fmt.Errorf(\"unknown message type\")\n")
	b.WriteString("}\n")
	b.WriteString("\n")
	return b.String()
}

func (g GoGenerator) getFieldType(field *model.Field) string {

	switch c := field.Attr.(type) {
	case *model.LengthFieldAttribute, *model.CheckSumFieldAttribute, *model.BasicFieldAttribute:
		return goBasicTypeMap[field.GetType()].BasicType
	case *model.DynamicStringFieldAttribute, *model.FixedStringFieldAttribute:
		return "string"
	case *model.MatchFieldAttribute:
		return "codec.BinaryCodec"
	case *model.ObjectFieldAttribute:
		return c.RefPacket.Name
	default:
		return "unknow type"
	}

}

func (g GoGenerator) generateStructCode(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("// " + p.Name + " represents the packet structure.\n")
	b.WriteString("type " + p.Name + " struct {\n")
	for _, field := range p.Fields {
		typ := g.getFieldType(field)
		if _, ok := field.Attr.(*model.ObjectFieldAttribute); ok {
			typ = "*" + typ
		}
		fieldNameCamel := strcase.ToCamel(field.Name)
		if field.IsRepeat {
			b.WriteString(fmt.Sprintf("    %s []%s `json:\"%s\"`\n", fieldNameCamel, typ, field.Name))
		} else {
			b.WriteString(fmt.Sprintf("    %s %s `json:\"%s\"`\n", fieldNameCamel, typ, field.Name))
		}
	}
	b.WriteString("}\n\n")
	b.WriteString("// New" + p.Name + " creates a new instance of " + p.Name + ".\n")
	b.WriteString("func New" + p.Name + "() *" + p.Name + " {\n")
	b.WriteString("    return &" + p.Name + "{}\n")
	b.WriteString("}\n\n")
	b.WriteString("// String returns a string representation of the packet.\n")
	b.WriteString("func (p *" + p.Name + ") String() string {\n")
	b.WriteString("    return fmt.Sprintf(\"" + p.Name + "{")
	for i, field := range p.Fields {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(fmt.Sprintf("%s: %%v", strcase.ToCamel(field.Name)))
	}
	b.WriteString("}\", ")
	for i, field := range p.Fields {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString("p." + strcase.ToCamel(field.Name))
	}
	b.WriteString(")\n")
	b.WriteString("}\n\n")
	return b.String()
}

func (g GoGenerator) generateDecodingCode(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("// Decode decodes the packet from a byte slice.\n")
	b.WriteString("func (p *" + p.Name + ") Decode(buf *bytes.Buffer) error {\n")
	for _, field := range p.Fields {
		if field.IsRepeat {
			b.WriteString(g.generateDecodingListField(field))
		} else {
			b.WriteString(g.generateDecodingField(p, field))
		}
	}
	b.WriteString("    return nil\n")
	b.WriteString("}\n\n")
	return b.String()
}

func (g GoGenerator) getOrder() string {
	order := ""
	if g.GetConfig().LittleEndian {
		order = "LE"
	}
	return order
}

// GetPadding field.Padding or config.Padding
func (g GoGenerator) GetPadding(f *model.Field) *model.Padding {
	padding := g.GetConfig().Padding
	if fs, ok := f.Attr.(*model.FixedStringFieldAttribute); ok {
		if fs.Padding != nil {
			padding = fs.Padding
		}
	}
	if padding == nil {
		return nil
	}

	if padding.PadChar == "'\x00'" || padding.PadChar == "'\\x00'" {
		padding.PadChar = "'\\x00'"
	}

	return padding
}

func (g GoGenerator) generateDecodingField(p *model.Packet, field *model.Field) string {
	var b strings.Builder
	order := g.getOrder()
	fieldNameCamel := strcase.ToCamel(field.Name)
	padding := g.GetPadding(field)
	switch c := field.Attr.(type) {
	case *model.FixedStringFieldAttribute:
		// fixed string
		if !padding.IsDefault() {
			b.WriteString(fmt.Sprintf("    if val,err := codec.ReadFixedStringTrimPadding(buf, %d, %s, %t); err != nil {\n", c.Length, padding.PadChar, padding.PadLeft))
		} else {
			b.WriteString(fmt.Sprintf("    if val,err := codec.ReadFixedString(buf, %d); err != nil {\n", c.Length))
		}
		b.WriteString("        return err\n")
		b.WriteString("    }  else {\n")
		b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
		b.WriteString("    }\n")
	case *model.DynamicStringFieldAttribute:
		//dynamic string
		strLenType := goBasicTypeMap[g.GetConfig().StringLenPrefixLenType]
		b.WriteString(fmt.Sprintf("    if val, err := codec.ReadString%s[%s](buf); err != nil {\n", order, strLenType.BasicType))
		b.WriteString("        return err\n")
		b.WriteString("    } else {\n")
		b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
		b.WriteString("    }\n")
	case *model.BasicFieldAttribute, *model.LengthFieldAttribute, *model.CheckSumFieldAttribute:
		if bt, ok := goBasicTypeMap[field.GetType()]; ok {
			b.WriteString(fmt.Sprintf("    if val, err := codec.ReadBasicType%s[%s](buf); err != nil {\n", order, bt.BasicType))
			b.WriteString("        return err\n")
			b.WriteString("    }  else {\n")
			b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
			b.WriteString("    }\n")
		}
	case *model.ObjectFieldAttribute:
		b.WriteString(fmt.Sprintf("    if p.%s == nil {\n", field.GetType()))
		b.WriteString(fmt.Sprintf("        p.%s = &%s{}\n", field.GetType(), field.GetType()))
		b.WriteString("    }\n")
		b.WriteString(fmt.Sprintf("    if err := p.%s.Decode(buf); err != nil {\n", fieldNameCamel))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	case *model.MatchFieldAttribute:
		b.WriteString(fmt.Sprintf("    if val, err :=New%sMessageBy%s(p.%s); err != nil {\n", strcase.ToCamel(p.Name), strcase.ToCamel(c.MatchKeyField.Name), strcase.ToCamel(c.MatchKeyField.Name)))
		b.WriteString("        return err\n")
		b.WriteString("    } else {\n")
		b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
		b.WriteString("    }\n")
		b.WriteString(fmt.Sprintf("    if err := p.%s.Decode(buf); err != nil {\n", fieldNameCamel))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	default:
		b.WriteString("--" + field.GetType() + ":" + field.Name + " is not supported for encoding--\n")
	}
	return b.String()
}

func (g GoGenerator) generateDecodingListField(field *model.Field) string {
	var b strings.Builder
	listLenType := goBasicTypeMap[g.GetConfig().ListLenPrefixLenType]
	order := g.getOrder()
	fieldNameCamel := strcase.ToCamel(field.Name)
	padding := g.GetPadding(field)
	switch c := field.Attr.(type) {
	case *model.BasicFieldAttribute:
		if bt, ok := goBasicTypeMap[field.GetType()]; ok {
			b.WriteString(fmt.Sprintf("    if val, err := codec.ReadBasicTypeList%s[%s,%s](buf); err != nil {\n", order, listLenType.BasicType, bt.BasicType))
			b.WriteString("        return err\n")
			b.WriteString("    }  else {\n")
			b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
			b.WriteString("    }\n")
		}
	case *model.FixedStringFieldAttribute:
		// fixed string
		if !padding.IsDefault() {
			b.WriteString(fmt.Sprintf("    if val,err := codec.ReadFixedStringListTrimPadding%s[%s](buf, %d, %s, %t); err != nil {\n", order, listLenType.BasicType, c.Length, padding.PadChar, padding.PadLeft))
		} else {
			b.WriteString(fmt.Sprintf("    if val,err := codec.ReadFixedStringList%s[%s](buf, %d); err != nil {\n", order, listLenType.BasicType, c.Length))
		}
		b.WriteString("        return err\n")
		b.WriteString("    }  else {\n")
		b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
		b.WriteString("    }\n")
	case *model.DynamicStringFieldAttribute:
		//dynamic string
		strLenType := goBasicTypeMap[g.GetConfig().StringLenPrefixLenType]
		b.WriteString(fmt.Sprintf("    if val, err := codec.ReadStringList%s[%s,%s](buf); err != nil {\n", order, listLenType.BasicType, strLenType.BasicType))
		b.WriteString("        return err\n")
		b.WriteString("    } else {\n")
		b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
		b.WriteString("    }\n")
	case *model.ObjectFieldAttribute:
		b.WriteString(fmt.Sprintf("    if val, err := codec.ReadObjectList%s[%s](buf,  func() *%s { return &%s{} }); err != nil {\n", order, listLenType.BasicType, strcase.ToCamel(field.GetType()), strcase.ToCamel(field.GetType())))
		b.WriteString("        return err\n")
		b.WriteString("    } else {\n")
		b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
		b.WriteString("    }\n")
	default:
		b.WriteString("--" + field.GetType() + ":" + field.Name + " is not supported for encoding--\n")
	}

	return b.String()
}

func (g GoGenerator) generateEncodingCode(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("// Encode encodes the packet into a byte slice.\n")
	b.WriteString("func (p *" + p.Name + ") Encode(buf *bytes.Buffer) error {\n")
	b.WriteString("    // Implement encoding logic here.\n")
	for _, field := range p.Fields {
		if field.IsRepeat {
			b.WriteString(g.generateEncodingListField(field))
		} else {
			b.WriteString(g.generateEncodingField(p, field))
		}
	}
	b.WriteString("    return nil\n")
	b.WriteString("}\n\n")
	return b.String()
}

func (g GoGenerator) generateEncodingField(p *model.Packet, field *model.Field) string {
	var b strings.Builder
	fieldNameCamel := strcase.ToCamel(field.Name)
	padding := g.GetPadding(field)
	order := g.getOrder()
	if _, ok := field.LenAttr.(*model.LengthFieldAttribute); ok {
		fieldNameLowerCamel := strcase.ToLowerCamel(field.Name)
		b.WriteString(fmt.Sprintf("%sStart := buf.Len()\n", fieldNameLowerCamel))
		b.WriteString(fmt.Sprintf("if p.%s != nil { \n", fieldNameCamel))
		b.WriteString(fmt.Sprintf("    if err := p.%s.Encode(buf); err != nil {\n", fieldNameCamel))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
		b.WriteString("}\n")
		b.WriteString(fmt.Sprintf("%sEnd := buf.Len()\n", fieldNameLowerCamel))
		typ := goBasicTypeMap[p.LengthField.GetType()]
		b.WriteString(fmt.Sprintf("p.%s = %s(%sEnd - %sStart)\n", strcase.ToCamel(p.LengthField.Name), typ.BasicType, fieldNameLowerCamel, fieldNameLowerCamel))
		if g.GetConfig().LittleEndian {
			b.WriteString(fmt.Sprintf("binary.LittleEndian.Put%s(buf.Bytes()[%sPos:%sPos + 4], p.%s)\n", strcase.ToCamel(typ.BasicType), fieldNameLowerCamel, fieldNameLowerCamel, strcase.ToCamel(p.LengthField.Name)))
		} else {
			b.WriteString(fmt.Sprintf("binary.BigEndian.Put%s(buf.Bytes()[%sPos:%sPos + 4], p.%s)\n", strcase.ToCamel(typ.BasicType), fieldNameLowerCamel, fieldNameLowerCamel, strcase.ToCamel(p.LengthField.Name)))
		}
		return b.String()
	}
	switch c := field.Attr.(type) {
	case *model.BasicFieldAttribute:
		if _, ok := goBasicTypeMap[field.GetType()]; ok {
			b.WriteString(fmt.Sprintf("    if err :=codec.WriteBasicType%s(buf, p.%s); err != nil {\n", order, fieldNameCamel))
			b.WriteString("        return fmt.Errorf(\"failed to encode %s: %w\", \"" + field.Name + "\", err)\n")
			b.WriteString("    }\n")
		}
	case *model.LengthFieldAttribute:
		typ := goBasicTypeMap[field.GetType()]
		b.WriteString(fmt.Sprintf("    %sPos := buf.Len()\n", strcase.ToLowerCamel(c.TragetField.Name)))
		b.WriteString(fmt.Sprintf("    if err :=codec.WriteBasicType%s(buf, %s(0)); err != nil {\n", order, typ.BasicType))
		b.WriteString("        return fmt.Errorf(\"failed to encode %s: %w\", \"" + field.Name + "\", err)\n")
		b.WriteString("    }\n")
	case *model.CheckSumFieldAttribute:
		typ := goBasicTypeMap[field.GetType()]
		b.WriteString(fmt.Sprintf("if checksumService, ok := codec.Get(%s); ok {\n", c.CheckSumType))
		b.WriteString(fmt.Sprintf("    p.%s = checksumService.(codec.ChecksumService[*bytes.Buffer, %s]).Calc(buf)\n", fieldNameCamel, typ.BasicType))
		b.WriteString("}\n")
		b.WriteString(fmt.Sprintf("    if err :=codec.WriteBasicType%s(buf, p.%s); err != nil {\n", order, fieldNameCamel))
		b.WriteString("        return fmt.Errorf(\"failed to encode %s: %w\", \"" + field.Name + "\", err)\n")
		b.WriteString("    }\n")
	case *model.FixedStringFieldAttribute:
		// fixed string
		if !padding.IsDefault() {
			b.WriteString(fmt.Sprintf("    if err := codec.WriteFixedStringWithPadding(buf, p.%s, %d, %s, %t); err != nil {\n", fieldNameCamel, c.Length, padding.PadChar, padding.PadLeft))
		} else {
			b.WriteString(fmt.Sprintf("    if err := codec.WriteFixedString(buf, p.%s, %d); err != nil {\n", fieldNameCamel, c.Length))
		}
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	case *model.DynamicStringFieldAttribute:
		//dynamic string
		strLenType := goBasicTypeMap[g.GetConfig().StringLenPrefixLenType]
		b.WriteString(fmt.Sprintf("    if err := codec.WriteString%s[%s](buf, p.%s); err != nil {\n", order, strLenType.BasicType, fieldNameCamel))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	case *model.ObjectFieldAttribute:
		b.WriteString(fmt.Sprintf("    if err := p.%s.Encode(buf); err != nil {\n", fieldNameCamel))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	case *model.MatchFieldAttribute:
		b.WriteString(fmt.Sprintf("if p.%s == nil {\n", fieldNameCamel))
		matchKeyCamel := strcase.ToCamel(c.MatchKeyField.Name)
		b.WriteString(fmt.Sprintf("    if val, err :=New%sMessageBy%s(p.%s); err != nil {\n", strcase.ToCamel(p.Name), matchKeyCamel, matchKeyCamel))
		b.WriteString("        return err\n")
		b.WriteString("    } else {\n")
		b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
		b.WriteString("    }\n")
		b.WriteString("}\n")
		b.WriteString(fmt.Sprintf("    if err := p.%s.Encode(buf); err != nil {\n", fieldNameCamel))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	default:
		b.WriteString("--" + field.GetType() + ":" + field.Name + " is not supported for encoding--\n")
	}

	return b.String()
}

func (g GoGenerator) generateEncodingListField(field *model.Field) string {
	var b strings.Builder
	listLenType := goBasicTypeMap[g.GetConfig().ListLenPrefixLenType]
	order := g.getOrder()
	fieldNameCamel := strcase.ToCamel(field.Name)
	padding := g.GetPadding(field)
	switch c := field.Attr.(type) {
	case *model.BasicFieldAttribute:
		if _, ok := goBasicTypeMap[field.GetType()]; ok {
			b.WriteString(fmt.Sprintf("    if err := codec.WriteBasicTypeList%s[%s](buf, p.%s); err != nil {\n", order, listLenType.BasicType, fieldNameCamel))
			b.WriteString("        return fmt.Errorf(\"failed to encode %s: %w\", \"" + field.Name + "\", err)\n")
			b.WriteString("    }\n")
		}
	case *model.DynamicStringFieldAttribute:
		//dynamic string
		strLenType := goBasicTypeMap[g.GetConfig().StringLenPrefixLenType]
		b.WriteString(fmt.Sprintf("    if err := codec.WriteStringList%s[%s,%s](buf, p.%s); err != nil {\n", order, listLenType.BasicType, strLenType.BasicType, fieldNameCamel))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	case *model.FixedStringFieldAttribute:
		// fixed string
		if !padding.IsDefault() {
			b.WriteString(fmt.Sprintf("    if err := codec.WriteFixedStringListWithPadding%s[%s](buf, p.%s, %d, %s, %t); err != nil {\n", order, listLenType.BasicType, fieldNameCamel, c.Length, padding.PadChar, padding.PadLeft))
		} else {
			b.WriteString(fmt.Sprintf("    if err := codec.WriteFixedStringList%s[%s](buf, p.%s, %d); err != nil {\n", order, listLenType.BasicType, fieldNameCamel, c.Length))
		}
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	case *model.ObjectFieldAttribute:
		b.WriteString(fmt.Sprintf("    if err := codec.WriteObjectList%s[%s](buf, p.%s); err != nil {\n", order, listLenType.BasicType, fieldNameCamel))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	default:
		b.WriteString("--" + field.GetType() + ":" + field.Name + " is not supported for encoding--\n")
	}

	return b.String()
}

func (g GoGenerator) generateGoTestFileForPacket(p *model.Packet, isIner bool) string {
	var b strings.Builder
	if !isIner {
		b.WriteString("// Code generated by fin-protoc. DO NOT EDIT.\n")
		b.WriteString(fmt.Sprintf("package %s_test", g.GetConfig().GoPackage))
		b.WriteString("\n\n")
		b.WriteString(`import (
		"bytes"
		"testing"

		"github.com/stretchr/testify/assert"
		`)
		b.WriteString(fmt.Sprintf("msg \"%s\"", g.GetConfig().GoModule))
		b.WriteString(")")
		b.WriteString("\n\n")
	}

	packageNameCamel := strcase.ToCamel(p.Name)
	b.WriteString(fmt.Sprintf("func Test%sCodec(t *testing.T) {\n", packageNameCamel))
	//new instance
	b.WriteString("\n")
	b.WriteString(g.generateNewInstance("original", p))

	//encode
	b.WriteString("    var buf bytes.Buffer\n")
	b.WriteString("    assert.NoError(t, original.Encode(&buf))\n")
	b.WriteString(fmt.Sprintf("    var decoded msg.%s\n", packageNameCamel))
	//decode
	b.WriteString("    assert.NoError(t, decoded.Decode(&buf))\n")
	//assert
	b.WriteString("    assert.Equal(t, original, &decoded)\n")

	b.WriteString("}\n")

	return b.String()
}

func (g GoGenerator) generateNewInstance(name string, p *model.Packet) string {
	var b strings.Builder
	for _, f := range p.Fields {
		fieldNameLowerCamel := strcase.ToLowerCamel(f.Name)
		switch c := f.Attr.(type) {
		case *model.ObjectFieldAttribute:
			b.WriteString(g.generateNewInstance(fieldNameLowerCamel, c.RefPacket))
		case *model.MatchFieldAttribute:
			mp := c.MatchPairs[0]
			valuePackage := g.binModel.PacketsMap[mp.Value]
			b.WriteString(g.generateNewInstance(fieldNameLowerCamel, valuePackage))

		}
	}
	b.WriteString(fmt.Sprintf("    %s := &msg.%s{\n", name, strcase.ToCamel(p.Name)))
	for _, f := range p.Fields {
		if mf, ok := f.Attr.(*model.MatchFieldAttribute); ok {
			if len(mf.MatchPairs) > 0 {
				key := mf.MatchPairs[0].Key
				b.WriteString(AddIndent4ln(AddIndent4(AddIndent4(fmt.Sprintf("%s: %s,", strcase.ToCamel(mf.MatchKeyField.Name), key)))))
				b.WriteString(AddIndent4ln(AddIndent4(AddIndent4(fmt.Sprintf("%s: %s,", strcase.ToCamel(f.Name), g.generateTestValue(f))))))
			}
			continue
		}
		if p.MatchFields[f.Name] != nil {
			continue
		}
		b.WriteString(fmt.Sprintf("    %s : %s,\n", strcase.ToCamel(f.Name), g.generateTestValue(f)))
	}
	b.WriteString("}\n")
	return b.String()
}

func (g GoGenerator) generateTestValue(f *model.Field) any {
	var testValue string
	ty := f.GetType()
	fieldNameLowerCamel := strcase.ToLowerCamel(f.Name)
	switch c := f.Attr.(type) {
	case *model.BasicFieldAttribute, *model.LengthFieldAttribute, *model.CheckSumFieldAttribute:
		if typ, ok := goBasicTypeMap[f.GetType()]; ok {
			testValue = typ.TestValue
			ty = typ.BasicType
		}
	case *model.FixedStringFieldAttribute:
		testValue = "\"" + strings.Repeat("x", c.Length) + "\""
		ty = "string"
	case *model.DynamicStringFieldAttribute:
		testValue = "\"hello\""
		ty = "string"
	case *model.MatchFieldAttribute, *model.ObjectFieldAttribute:
		testValue = fieldNameLowerCamel
	default:
		testValue = "-- unsupport " + f.GetType()
	}
	if f.IsRepeat {
		if _, ok := f.Attr.(*model.ObjectFieldAttribute); ok {
			return fmt.Sprintf("[]*msg.%s{%s}", ty, testValue)
		}
		return fmt.Sprintf("[]%s{%s}", ty, testValue)
	}
	return testValue
}
