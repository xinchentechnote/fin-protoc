package parser

import (
	"fmt"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/xinchentechnote/fin-protoc/internal/model"
)

// GoType represents a Go type with its properties
type GoType struct {
	Name      string
	BasicType string
	TestValue string
	Le        string
	Size      uint32
}

var goBasicTypeMap = map[string]GoType{
	"i8":  {"i8", "int8", "1", "binary.LittleEndian", 1},
	"i16": {"i16", "int16", "2", "binary.LittleEndian", 2},
	"i32": {"i32", "int32", "4", "binary.LittleEndian", 4},
	"i64": {"i64", "int64", "8", "binary.LittleEndian", 8},
	"u8":  {"u8", "uint8", "1", "binary.LittleEndian", 1},
	"u16": {"u16", "uint16", "2", "binary.LittleEndian", 2},
	"u32": {"u32", "uint32", "4", "binary.LittleEndian", 4},
	"u64": {"u64", "uint64", "8", "binary.LittleEndian", 8},
	"f32": {"f32", "float32", "4", "binary.LittleEndian", 4},
	"f64": {"f64", "float64", "8", "binary.LittleEndian", 8},
}

// GoGenerator a go code generator
type GoGenerator struct {
	config   *GeneratorConfig
	binModel *model.BinaryModel
}

// NewGoGenerator new
func NewGoGenerator(config *GeneratorConfig, binModel *model.BinaryModel) *GoGenerator {
	return &GoGenerator{
		config:   config,
		binModel: binModel,
	}
}

// Generate go code
func (g GoGenerator) Generate(binModel *model.BinaryModel) (map[string][]byte, error) {
	output := make(map[string][]byte)
	for _, pkt := range binModel.PacketsMap {
		code := g.generateGoFileForPacket(&pkt, false)
		output[strcase.ToSnake(pkt.Name)+".go"] = []byte(code)
	}
	return output, nil
}

func (g GoGenerator) generateGoFileForPacket(p *model.Packet, isIner bool) string {
	var b strings.Builder
	if !isIner {
		b.WriteString("// Code generated by fin-protoc. DO NOT EDIT.\n")
		b.WriteString(fmt.Sprintf("package %s", g.config.GoPackage))
		b.WriteString("\n\n")
		b.WriteString(`import (
		"bytes"
		"fmt"
		"encoding/binary"
	
		"github.com/xinchentechnote/fin-proto-go/internal/codec"
	)`)
		b.WriteString("\n\n")
	}

	for _, f := range p.Fields {
		if f.InerObject != nil {
			b.WriteString(g.generateGoFileForPacket(f.InerObject, true))
		}
	}

	b.WriteString(g.generateStructCode(p))
	b.WriteString("\n\n")
	b.WriteString(g.generateEncodingCode(p))
	b.WriteString("\n\n")
	b.WriteString(g.generateDecodingCode(p))
	b.WriteString("\n\n")

	return b.String()
}

func (g GoGenerator) getFieldType(field *model.Field) string {

	if t, ok := goBasicTypeMap[field.Type]; ok {
		return t.BasicType
	}
	if _, ok := ParseCharArrayType(field.Type); ok {
		return "string"
	}
	switch field.Type {
	case "string", "char[]":
		return "string"
	case "match":
		return "codec.BinaryCodec"
	}
	return field.Type // Fallback for unknown types
}

func (g GoGenerator) generateStructCode(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("// " + p.Name + " represents the packet structure.\n")
	b.WriteString("type " + p.Name + " struct {\n")
	for _, field := range p.Fields {
		b.WriteString(fmt.Sprintf("    %s %s `json:\"%s\"`\n", strcase.ToCamel(field.Name), g.getFieldType(&field), field.Name))
	}
	b.WriteString("}\n\n")
	b.WriteString("// New" + p.Name + " creates a new instance of " + p.Name + ".\n")
	b.WriteString("func New" + p.Name + "() *" + p.Name + " {\n")
	b.WriteString("    return &" + p.Name + "{}\n")
	b.WriteString("}\n\n")
	b.WriteString("// String returns a string representation of the packet.\n")
	b.WriteString("func (p *" + p.Name + ") String() string {\n")
	b.WriteString("    return fmt.Sprintf(\"" + p.Name + "{")
	for i, field := range p.Fields {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(fmt.Sprintf("%s: %%v", strcase.ToCamel(field.Name)))
	}
	b.WriteString("}\", ")
	for i, field := range p.Fields {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString("p." + strcase.ToCamel(field.Name))
	}
	b.WriteString(")\n")
	b.WriteString("}\n\n")
	return b.String()
}

func (g GoGenerator) generateDecodingCode(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("// Decode decodes the packet from a byte slice.\n")
	b.WriteString("func (p *" + p.Name + ") Decode(buf *bytes.Buffer) error {\n")
	for _, field := range p.Fields {
		if _, ok := goBasicTypeMap[field.Type]; ok {
			b.WriteString(fmt.Sprintf("    if err := binary.Read(buf, %s, &p.%s); err != nil {\n", goBasicTypeMap[field.Type].Le, strcase.ToCamel(field.Name)))
			b.WriteString("        return fmt.Errorf(\"failed to decode %s: %w\", \"" + field.Name + "\", err)\n")
			b.WriteString("    }\n")
			continue
		}
		if len, ok := ParseCharArrayType(field.Type); ok {
			// fixed string
			b.WriteString(fmt.Sprintf("    if val,err := codec.GetFixedString(buf, %s); err != nil {\n", len))
			b.WriteString("        return err\n")
			b.WriteString("    }  else {\n")
			b.WriteString(fmt.Sprintf("        p.%s = val\n", strcase.ToCamel(field.Name)))
			b.WriteString("    }\n")
			continue
		}
		if field.InerObject != nil {
			b.WriteString(fmt.Sprintf("    if err := p.%s.Decode(buf); err != nil {\n", strcase.ToCamel(field.Name)))
			b.WriteString("        return err\n")
			b.WriteString("    }\n")
			continue
		}
		if _, ok := g.binModel.PacketsMap[field.Type]; ok {
			b.WriteString(fmt.Sprintf("    if err := p.%s.Decode(buf); err != nil {\n", strcase.ToCamel(field.Name)))
			b.WriteString("        return err\n")
			b.WriteString("    }\n")
			continue
		}
		if field.Type == "string" || field.Type == "char[]" {
			//dynamic string
			strLenType := goBasicTypeMap[g.config.StringLenPrefixLenType]
			b.WriteString(fmt.Sprintf("    if val, err := codec.GetString[%s](buf); err != nil {\n", strLenType.BasicType))
			b.WriteString("        return err\n")
			b.WriteString("    } else {\n")
			b.WriteString(fmt.Sprintf("        p.%s = val\n", strcase.ToCamel(field.Name)))
			b.WriteString("    }\n")
			continue
		}
		if field.Type == "match" {

			if len(field.MatchPairs) > 0 {
				b.WriteString(fmt.Sprintf("switch p.%s {\n", field.MatchKey))
				for _, mp := range field.MatchPairs {
					b.WriteString(fmt.Sprintf("case %s: \n", mp.Key))
					b.WriteString(fmt.Sprintf("    p.%s = &%s{} \n", strcase.ToCamel(field.Name), strcase.ToCamel(mp.Value)))
				}
				b.WriteString("default:\n")
				b.WriteString(fmt.Sprintf("    return fmt.Errorf(\"unsupported %s: %%v\", p.%s)\n", field.MatchKey, field.MatchKey))
				b.WriteString("}\n")
			}

			b.WriteString(fmt.Sprintf("    if err := p.%s.Decode(buf); err != nil {\n", strcase.ToCamel(field.Name)))
			b.WriteString("        return err\n")
			b.WriteString("    }\n")
			continue
		}
		b.WriteString("--" + field.Type + ":" + field.Name + " is not supported for encoding--\n")
	}
	b.WriteString("    return nil\n")
	b.WriteString("}\n\n")
	return b.String()
}

func (g GoGenerator) generateEncodingCode(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("// Encode encodes the packet into a byte slice.\n")
	b.WriteString("func (p *" + p.Name + ") Encode(buf *bytes.Buffer) error {\n")
	b.WriteString("    // Implement encoding logic here.\n")
	for _, field := range p.Fields {
		if _, ok := goBasicTypeMap[field.Type]; ok {
			b.WriteString(fmt.Sprintf("    if err := binary.Write(buf, %s, p.%s); err != nil {\n", goBasicTypeMap[field.Type].Le, strcase.ToCamel(field.Name)))
			b.WriteString("        return fmt.Errorf(\"failed to encode %s: %w\", \"" + field.Name + "\", err)\n")
			b.WriteString("    }\n")
			continue
		}
		if len, ok := ParseCharArrayType(field.Type); ok {
			// fixed string
			b.WriteString(fmt.Sprintf("    if err := codec.PutFixedString(buf, p.%s, %s); err != nil {\n", strcase.ToCamel(field.Name), len))
			b.WriteString("        return err\n")
			b.WriteString("    }\n")
			continue
		}
		if field.InerObject != nil {
			b.WriteString(fmt.Sprintf("    if err := p.%s.Encode(buf); err != nil {\n", strcase.ToCamel(field.Name)))
			b.WriteString("        return err\n")
			b.WriteString("    }\n")
			continue
		}
		if _, ok := g.binModel.PacketsMap[field.Type]; ok {
			b.WriteString(fmt.Sprintf("    if err := p.%s.Encode(buf); err != nil {\n", strcase.ToCamel(field.Name)))
			b.WriteString("        return err\n")
			b.WriteString("    }\n")
			continue
		}
		if field.Type == "string" || field.Type == "char[]" {
			//dynamic string
			strLenType := goBasicTypeMap[g.config.StringLenPrefixLenType]
			b.WriteString(fmt.Sprintf("    if err := codec.PutString[%s](buf, p.%s); err != nil {\n", strLenType.BasicType, strcase.ToCamel(field.Name)))
			b.WriteString("        return err\n")
			b.WriteString("    }\n")
			continue
		}
		if field.Type == "match" {
			b.WriteString(fmt.Sprintf("    if err := p.%s.Encode(buf); err != nil {\n", strcase.ToCamel(field.Name)))
			b.WriteString("        return err\n")
			b.WriteString("    }\n")
			continue
		}
		b.WriteString("--" + field.Type + ":" + field.Name + " is not supported for encoding--\n")
	}
	b.WriteString("    return nil\n")
	b.WriteString("}\n\n")
	return b.String()
}
