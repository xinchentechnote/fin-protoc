package parser

import (
	"fmt"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/xinchentechnote/fin-protoc/internal/model"
)

// GoType represents a Go type with its properties
type GoType struct {
	Name      string
	BasicType string
	TestValue string
	Le        string
	Size      uint32
}

var goBasicTypeMap = map[string]GoType{
	"i8":  {"i8", "int8", "1", "binary.LittleEndian", 1},
	"i16": {"i16", "int16", "2", "binary.LittleEndian", 2},
	"i32": {"i32", "int32", "4", "binary.LittleEndian", 4},
	"i64": {"i64", "int64", "8", "binary.LittleEndian", 8},
	"u8":  {"u8", "uint8", "1", "binary.LittleEndian", 1},
	"u16": {"u16", "uint16", "2", "binary.LittleEndian", 2},
	"u32": {"u32", "uint32", "4", "binary.LittleEndian", 4},
	"u64": {"u64", "uint64", "8", "binary.LittleEndian", 8},
	"f32": {"f32", "float32", "4", "binary.LittleEndian", 4},
	"f64": {"f64", "float64", "8", "binary.LittleEndian", 8},
}

// GoGenerator a go code generator
type GoGenerator struct {
	config   *GeneratorConfig
	binModel *model.BinaryModel
}

// NewGoGenerator new
func NewGoGenerator(config *GeneratorConfig, binModel *model.BinaryModel) *GoGenerator {
	return &GoGenerator{
		config:   config,
		binModel: binModel,
	}
}

// Generate go code
func (g GoGenerator) Generate(binModel *model.BinaryModel) (map[string][]byte, error) {
	output := make(map[string][]byte)
	for _, pkt := range binModel.PacketsMap {
		code := g.generateGoFileForPacket(&pkt, false)
		output[strcase.ToSnake(pkt.Name)+".go"] = []byte(code)
	}
	return output, nil
}

func (g GoGenerator) generateGoFileForPacket(p *model.Packet, isIner bool) string {
	var b strings.Builder
	if !isIner {
		b.WriteString("// Code generated by fin-protoc. DO NOT EDIT.\n")
		b.WriteString(fmt.Sprintf("package %s", g.config.GoPackage))
		b.WriteString("\n\n")
		b.WriteString(`import (
		"bytes"
		"fmt"
		"encoding/binary"
	
		"github.com/xinchentechnote/fin-proto-go/internal/codec"
	)`)
		b.WriteString("\n\n")
	}

	for _, f := range p.Fields {
		if f.InerObject != nil {
			b.WriteString(g.generateGoFileForPacket(f.InerObject, true))
		}
	}

	b.WriteString(g.generateStructCode(p))
	b.WriteString("\n\n")
	b.WriteString(g.generateEncodingCode(p))
	b.WriteString("\n\n")
	b.WriteString(g.generateDecodingCode(p))
	b.WriteString("\n\n")

	return b.String()
}

func (g GoGenerator) getFieldType(field *model.Field) string {

	if t, ok := goBasicTypeMap[field.Type]; ok {
		return t.BasicType
	}
	if _, ok := ParseCharArrayType(field.Type); ok {
		return "string"
	}
	switch field.Type {
	case "string", "char[]":
		return "string"
	case "match":
		return "codec.BinaryCodec"
	}
	return field.Type // Fallback for unknown types
}

func (g GoGenerator) generateStructCode(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("// " + p.Name + " represents the packet structure.\n")
	b.WriteString("type " + p.Name + " struct {\n")
	for _, field := range p.Fields {
		b.WriteString(fmt.Sprintf("    %s %s `json:\"%s\"`\n", strcase.ToCamel(field.Name), g.getFieldType(&field), field.Name))
	}
	b.WriteString("}\n\n")
	b.WriteString("// New" + p.Name + " creates a new instance of " + p.Name + ".\n")
	b.WriteString("func New" + p.Name + "() *" + p.Name + " {\n")
	b.WriteString("    return &" + p.Name + "{}\n")
	b.WriteString("}\n\n")
	b.WriteString("// String returns a string representation of the packet.\n")
	b.WriteString("func (p *" + p.Name + ") String() string {\n")
	b.WriteString("    return fmt.Sprintf(\"" + p.Name + "{")
	for i, field := range p.Fields {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(fmt.Sprintf("%s: %%v", strcase.ToCamel(field.Name)))
	}
	b.WriteString("}\", ")
	for i, field := range p.Fields {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString("p." + strcase.ToCamel(field.Name))
	}
	b.WriteString(")\n")
	b.WriteString("}\n\n")
	return b.String()
}

func (g GoGenerator) generateDecodingCode(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("// Decode decodes the packet from a byte slice.\n")
	b.WriteString("func (p *" + p.Name + ") Decode(buf *bytes.Buffer) error {\n")
	b.WriteString("    // Implement decoding logic here.\n")
	b.WriteString("    return nil\n")
	b.WriteString("}\n\n")
	return b.String()
}

func (g GoGenerator) generateEncodingCode(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("// Encode encodes the packet into a byte slice.\n")
	b.WriteString("func (p *" + p.Name + ") Encode(buf *bytes.Buffer) error {\n")
	b.WriteString("    // Implement encoding logic here.\n")
	b.WriteString("    return nil\n")
	b.WriteString("}\n\n")
	return b.String()
}
