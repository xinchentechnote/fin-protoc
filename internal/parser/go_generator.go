package parser

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/xinchentechnote/fin-protoc/internal/model"
)

// GoType represents a Go type with its properties
type GoType struct {
	Name      string
	BasicType string
	TestValue string
	Size      uint32
}

var goBasicTypeMap = map[string]GoType{
	"i8":  {"i8", "int8", "1", 1},
	"i16": {"i16", "int16", "2", 2},
	"i32": {"i32", "int32", "4", 4},
	"i64": {"i64", "int64", "8", 8},
	"u8":  {"u8", "uint8", "1", 1},
	"u16": {"u16", "uint16", "2", 2},
	"u32": {"u32", "uint32", "4", 4},
	"u64": {"u64", "uint64", "8", 8},
	"f32": {"f32", "float32", "4", 4},
	"f64": {"f64", "float64", "8", 8},
}

// GoGenerator a go code generator
type GoGenerator struct {
	config   *GeneratorConfig
	binModel *model.BinaryModel
}

// NewGoGenerator new
func NewGoGenerator(config *GeneratorConfig, binModel *model.BinaryModel) *GoGenerator {
	return &GoGenerator{
		config:   config,
		binModel: binModel,
	}
}

// Generate go code
func (g GoGenerator) Generate(binModel *model.BinaryModel) (map[string][]byte, error) {
	output := make(map[string][]byte)
	for _, pkt := range binModel.PacketsMap {
		code := g.generateGoFileForPacket(&pkt, false)
		output[strcase.ToSnake(pkt.Name)+".go"] = []byte(code)
		code = g.generateGoTestFileForPacket(&pkt, false)
		output[strcase.ToSnake(pkt.Name)+"_test.go"] = []byte(code)
	}
	return output, nil
}

func (g GoGenerator) generateGoFileForPacket(p *model.Packet, isIner bool) string {
	var b strings.Builder
	if !isIner {
		b.WriteString("// Code generated by fin-protoc. DO NOT EDIT.\n")
		b.WriteString(fmt.Sprintf("package %s", g.config.GoPackage))
		b.WriteString("\n\n")
		b.WriteString(`import (
		"bytes"
		"fmt"
		"encoding/binary"
	
		"github.com/xinchentechnote/fin-proto-go/codec"
	)`)
		b.WriteString("\n\n")
	}

	// gen init
	b.WriteString("func init() {\n")
	for _, f := range p.Fields {
		if f.GetType() == "match" {
			b.WriteString(g.generateInit(p, &f))
		}
	}
	b.WriteString("}\n")
	b.WriteString("\n")

	// gen MessageFactory
	for _, f := range p.Fields {
		if f.GetType() == "match" {
			b.WriteString(g.generateMessageFactory(p, &f))
		}
	}

	for _, f := range p.Fields {
		if f.InerObject != nil {
			b.WriteString(g.generateGoFileForPacket(f.InerObject, true))
		}
	}

	b.WriteString(g.generateStructCode(p))
	b.WriteString("\n\n")
	b.WriteString(g.generateEncodingCode(p))
	b.WriteString("\n\n")
	b.WriteString(g.generateDecodingCode(p))
	b.WriteString("\n\n")

	return b.String()
}

func (g GoGenerator) generateInit(p *model.Packet, field *model.Field) string {
	var b strings.Builder
	for _, pair := range field.MatchPairs {
		b.WriteString(fmt.Sprintf("Registry%s%sFactory(%s, func() codec.BinaryCodec {return &%s{}})\n", strcase.ToCamel(p.Name), strcase.ToCamel(field.MatchKey), pair.Key, pair.Value))
	}
	return b.String()
}

func (g GoGenerator) generateMessageFactory(p *model.Packet, field *model.Field) string {
	typ := "unknow"
	if mf, ok := p.FieldMap[field.MatchKey]; ok {
		typ = mf.GetType()
		if t, ok := goBasicTypeMap[mf.GetType()]; ok {
			typ = t.BasicType
		}
		if _, ok := ParseCharArrayType(mf.GetType()); ok {
			typ = "string"
		}
	}
	var b strings.Builder
	packageNameLowerCamel := strcase.ToLowerCamel(p.Name)
	packageNameCamel := strcase.ToCamel(p.Name)
	matchKeyLowerCamel := strcase.ToLowerCamel(field.MatchKey)
	matchKeyCamel := strcase.ToCamel(field.MatchKey)
	b.WriteString(fmt.Sprintf("var %s%sFactoryCache = map[%s]func() codec.BinaryCodec{}\n", packageNameLowerCamel, matchKeyCamel, typ))
	b.WriteString("\n")
	//
	b.WriteString(fmt.Sprintf("func Registry%s%sFactory(%s %s,factory func() codec.BinaryCodec) {\n", packageNameCamel, matchKeyCamel, matchKeyLowerCamel, typ))
	b.WriteString(fmt.Sprintf("    %s%sFactoryCache[%s] = factory\n", packageNameLowerCamel, matchKeyCamel, matchKeyLowerCamel))
	b.WriteString("}\n")
	//
	b.WriteString("\n")
	b.WriteString(fmt.Sprintf("func New%sMessageBy%s(key %s) (codec.BinaryCodec, error) {\n", packageNameCamel, matchKeyCamel, typ))
	b.WriteString(fmt.Sprintf("    if factory, ok := %s%sFactoryCache[key]; ok{\n", packageNameLowerCamel, matchKeyCamel))
	b.WriteString("        return factory(),nil\n")
	b.WriteString("    }\n")
	b.WriteString("    return nil, fmt.Errorf(\"unknown message type\")\n")
	b.WriteString("}\n")
	b.WriteString("\n")
	return b.String()
}

func (g GoGenerator) getFieldType(field *model.Field) string {

	if t, ok := goBasicTypeMap[field.GetType()]; ok {
		return t.BasicType
	}
	if _, ok := ParseCharArrayType(field.GetType()); ok {
		return "string"
	}
	if field.InerObject != nil {
		return field.Name
	}
	switch field.GetType() {
	case "string", "char[]":
		return "string"
	case "match":
		return "codec.BinaryCodec"
	}
	return field.GetType() // Fallback for unknown types
}

func (g GoGenerator) generateStructCode(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("// " + p.Name + " represents the packet structure.\n")
	b.WriteString("type " + p.Name + " struct {\n")
	for _, field := range p.Fields {
		typ := g.getFieldType(&field)
		if field.InerObject != nil {
			typ = "*" + typ
		} else if _, ok := g.binModel.PacketsMap[field.GetType()]; ok {
			typ = "*" + typ
		}
		fieldNameCamel := strcase.ToCamel(field.Name)
		if field.IsRepeat {
			b.WriteString(fmt.Sprintf("    %s []%s `json:\"%s\"`\n", fieldNameCamel, typ, field.Name))
		} else {
			b.WriteString(fmt.Sprintf("    %s %s `json:\"%s\"`\n", fieldNameCamel, typ, field.Name))
		}
	}
	b.WriteString("}\n\n")
	b.WriteString("// New" + p.Name + " creates a new instance of " + p.Name + ".\n")
	b.WriteString("func New" + p.Name + "() *" + p.Name + " {\n")
	b.WriteString("    return &" + p.Name + "{}\n")
	b.WriteString("}\n\n")
	b.WriteString("// String returns a string representation of the packet.\n")
	b.WriteString("func (p *" + p.Name + ") String() string {\n")
	b.WriteString("    return fmt.Sprintf(\"" + p.Name + "{")
	for i, field := range p.Fields {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(fmt.Sprintf("%s: %%v", strcase.ToCamel(field.Name)))
	}
	b.WriteString("}\", ")
	for i, field := range p.Fields {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString("p." + strcase.ToCamel(field.Name))
	}
	b.WriteString(")\n")
	b.WriteString("}\n\n")
	return b.String()
}

func (g GoGenerator) generateDecodingCode(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("// Decode decodes the packet from a byte slice.\n")
	b.WriteString("func (p *" + p.Name + ") Decode(buf *bytes.Buffer) error {\n")
	for _, field := range p.Fields {
		if field.IsRepeat {
			b.WriteString(g.generateDecodingListField(&field))
		} else {
			b.WriteString(g.generateDecodingField(p, &field))
		}
	}
	b.WriteString("    return nil\n")
	b.WriteString("}\n\n")
	return b.String()
}

func (g GoGenerator) getOrder() string {
	order := ""
	if g.config.LittleEndian {
		order = "LE"
	}
	return order
}
func (g GoGenerator) generateDecodingField(p *model.Packet, field *model.Field) string {
	var b strings.Builder
	order := g.getOrder()
	fieldNameCamel := strcase.ToCamel(field.Name)
	if bt, ok := goBasicTypeMap[field.GetType()]; ok {
		b.WriteString(fmt.Sprintf("    if val, err := codec.GetBasicType%s[%s](buf); err != nil {\n", order, bt.BasicType))
		b.WriteString("        return err\n")
		b.WriteString("    }  else {\n")
		b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
		b.WriteString("    }\n")
	} else if l, ok := ParseCharArrayType(field.GetType()); ok {
		// fixed string
		b.WriteString(fmt.Sprintf("    if val,err := codec.GetFixedString(buf, %s); err != nil {\n", l))
		b.WriteString("        return err\n")
		b.WriteString("    }  else {\n")
		b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
		b.WriteString("    }\n")
	} else if field.InerObject != nil {
		b.WriteString(fmt.Sprintf("    if p.%s == nil {\n", field.Name))
		b.WriteString(fmt.Sprintf("        p.%s = &%s{}\n", field.Name, field.Name))
		b.WriteString("    }\n")
		b.WriteString(fmt.Sprintf("    if err := p.%s.Decode(buf); err != nil {\n", fieldNameCamel))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")

	} else if _, ok := g.binModel.PacketsMap[field.GetType()]; ok {
		b.WriteString(fmt.Sprintf("    if p.%s == nil {\n", field.GetType()))
		b.WriteString(fmt.Sprintf("        p.%s = &%s{}\n", field.GetType(), field.GetType()))
		b.WriteString("    }\n")
		b.WriteString(fmt.Sprintf("    if err := p.%s.Decode(buf); err != nil {\n", fieldNameCamel))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")

	} else if field.GetType() == "string" || field.GetType() == "char[]" {
		//dynamic string
		strLenType := goBasicTypeMap[g.config.StringLenPrefixLenType]
		b.WriteString(fmt.Sprintf("    if val, err := codec.GetString%s[%s](buf); err != nil {\n", order, strLenType.BasicType))
		b.WriteString("        return err\n")
		b.WriteString("    } else {\n")
		b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
		b.WriteString("    }\n")

	} else if field.GetType() == "match" {
		b.WriteString(fmt.Sprintf("    if val, err :=New%sMessageBy%s(p.%s); err != nil {\n", strcase.ToCamel(p.Name), strcase.ToCamel(field.MatchKey), strcase.ToCamel(field.MatchKey)))
		b.WriteString("        return err\n")
		b.WriteString("    } else {\n")
		b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
		b.WriteString("    }\n")
		b.WriteString(fmt.Sprintf("    if err := p.%s.Decode(buf); err != nil {\n", fieldNameCamel))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")

	} else {
		b.WriteString("--" + field.GetType() + ":" + field.Name + " is not supported for encoding--\n")
	}
	return b.String()
}

func (g GoGenerator) generateDecodingListField(field *model.Field) string {
	var b strings.Builder
	listLenType := goBasicTypeMap[g.config.ListLenPrefixLenType]
	order := g.getOrder()
	fieldNameCamel := strcase.ToCamel(field.Name)
	if bt, ok := goBasicTypeMap[field.GetType()]; ok {
		b.WriteString(fmt.Sprintf("    if val, err := codec.GetBasicTypeList%s[%s,%s](buf); err != nil {\n", order, listLenType.BasicType, bt.BasicType))
		b.WriteString("        return err\n")
		b.WriteString("    }  else {\n")
		b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
		b.WriteString("    }\n")
	} else if l, ok := ParseCharArrayType(field.GetType()); ok {
		// fixed string
		b.WriteString(fmt.Sprintf("    if val,err := codec.GetFixedStringList%s[%s](buf, %s); err != nil {\n", order, listLenType.BasicType, l))
		b.WriteString("        return err\n")
		b.WriteString("    }  else {\n")
		b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
		b.WriteString("    }\n")
	} else if field.InerObject != nil {
		b.WriteString(fmt.Sprintf("    if val, err := codec.GetObjectList%s[%s](buf,  func() *%s { return &%s{} }); err != nil {\n", order, listLenType.BasicType, strcase.ToCamel(field.GetType()), strcase.ToCamel(field.GetType())))
		b.WriteString("        return err\n")
		b.WriteString("    } else {\n")
		b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
		b.WriteString("    }\n")
	} else if _, ok := g.binModel.PacketsMap[field.GetType()]; ok {
		b.WriteString(fmt.Sprintf("    if val, err := codec.GetObjectList%s[%s](buf,  func() *%s { return &%s{} }); err != nil {\n", order, listLenType.BasicType, strcase.ToCamel(field.GetType()), strcase.ToCamel(field.GetType())))
		b.WriteString("        return err\n")
		b.WriteString("    } else {\n")
		b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
		b.WriteString("    }\n")
	} else if field.GetType() == "string" || field.GetType() == "char[]" {
		//dynamic string
		strLenType := goBasicTypeMap[g.config.StringLenPrefixLenType]
		b.WriteString(fmt.Sprintf("    if val, err := codec.GetStringList%s[%s,%s](buf); err != nil {\n", order, listLenType.BasicType, strLenType.BasicType))
		b.WriteString("        return err\n")
		b.WriteString("    } else {\n")
		b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
		b.WriteString("    }\n")
	} else {
		b.WriteString("--" + field.GetType() + ":" + field.Name + " is not supported for encoding--\n")
	}
	return b.String()
}

func (g GoGenerator) generateEncodingCode(p *model.Packet) string {
	var b strings.Builder
	b.WriteString("// Encode encodes the packet into a byte slice.\n")
	b.WriteString("func (p *" + p.Name + ") Encode(buf *bytes.Buffer) error {\n")
	b.WriteString("    // Implement encoding logic here.\n")
	for _, field := range p.Fields {
		if field.IsRepeat {
			b.WriteString(g.generateEncodingListField(&field))
		} else {
			b.WriteString(g.generateEncodingField(p, &field))
		}
	}
	b.WriteString("    return nil\n")
	b.WriteString("}\n\n")
	return b.String()
}

func (g GoGenerator) generateEncodingField(p *model.Packet, field *model.Field) string {
	var b strings.Builder
	fieldNameCamel := strcase.ToCamel(field.Name)
	if field.CheckSumType != "" {
		typ := goBasicTypeMap[field.GetType()]
		b.WriteString(fmt.Sprintf("if checksumService, ok := codec.Get(%s); ok {\n", field.CheckSumType))
		b.WriteString(fmt.Sprintf("    p.%s = checksumService.(codec.ChecksumService[*bytes.Buffer, %s]).Calc(buf)\n", fieldNameCamel, typ.BasicType))
		b.WriteString("}\n")
	}
	order := g.getOrder()
	if field.LengthOfField != "" {
		typ := goBasicTypeMap[field.GetType()]
		b.WriteString(fmt.Sprintf("    %sPos := buf.Len()\n", strcase.ToLowerCamel(field.LengthOfField)))
		b.WriteString(fmt.Sprintf("    if err :=codec.PutBasicType%s(buf, %s(0)); err != nil {\n", order, typ.BasicType))
		b.WriteString("        return fmt.Errorf(\"failed to encode %s: %w\", \"" + field.Name + "\", err)\n")
		b.WriteString("    }\n")
	} else if _, ok := goBasicTypeMap[field.GetType()]; ok {
		b.WriteString(fmt.Sprintf("    if err :=codec.PutBasicType%s(buf, p.%s); err != nil {\n", order, fieldNameCamel))
		b.WriteString("        return fmt.Errorf(\"failed to encode %s: %w\", \"" + field.Name + "\", err)\n")
		b.WriteString("    }\n")
	} else if p.LengthField != nil && field.Name == p.LengthField.LengthOfField {
		fieldNameLowerCamel := strcase.ToLowerCamel(field.Name)
		b.WriteString(fmt.Sprintf("%sStart := buf.Len()\n", fieldNameLowerCamel))
		b.WriteString(fmt.Sprintf("if p.%s != nil { \n", fieldNameCamel))
		b.WriteString(fmt.Sprintf("    if err := p.%s.Encode(buf); err != nil {\n", fieldNameCamel))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
		b.WriteString("}\n")
		b.WriteString(fmt.Sprintf("%sEnd := buf.Len()\n", fieldNameLowerCamel))
		typ := goBasicTypeMap[p.LengthField.GetType()]
		b.WriteString(fmt.Sprintf("p.%s = %s(%sEnd - %sStart)\n", strcase.ToCamel(p.LengthField.Name), typ.BasicType, fieldNameLowerCamel, fieldNameLowerCamel))
		if g.config.LittleEndian {
			b.WriteString(fmt.Sprintf("binary.LittleEndian.Put%s(buf.Bytes()[%sPos:%sPos + 4], p.%s)\n", strcase.ToCamel(typ.BasicType), fieldNameLowerCamel, fieldNameLowerCamel, strcase.ToCamel(p.LengthField.Name)))
		} else {
			b.WriteString(fmt.Sprintf("binary.BigEndian.Put%s(buf.Bytes()[%sPos:%sPos + 4], p.%s)\n", strcase.ToCamel(typ.BasicType), fieldNameLowerCamel, fieldNameLowerCamel, strcase.ToCamel(p.LengthField.Name)))
		}
	} else if l, ok := ParseCharArrayType(field.GetType()); ok {
		// fixed string
		b.WriteString(fmt.Sprintf("    if err := codec.PutFixedString(buf, p.%s, %s); err != nil {\n", fieldNameCamel, l))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	} else if field.InerObject != nil {
		b.WriteString(fmt.Sprintf("    if err := p.%s.Encode(buf); err != nil {\n", fieldNameCamel))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	} else if _, ok := g.binModel.PacketsMap[field.GetType()]; ok {
		b.WriteString(fmt.Sprintf("    if err := p.%s.Encode(buf); err != nil {\n", fieldNameCamel))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	} else if field.GetType() == "string" || field.GetType() == "char[]" {
		//dynamic string
		strLenType := goBasicTypeMap[g.config.StringLenPrefixLenType]
		b.WriteString(fmt.Sprintf("    if err := codec.PutString%s[%s](buf, p.%s); err != nil {\n", order, strLenType.BasicType, fieldNameCamel))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	} else if field.GetType() == "match" {
		b.WriteString(fmt.Sprintf("if p.%s == nil {\n", fieldNameCamel))
		matchKeyCamel := strcase.ToCamel(field.MatchKey)
		b.WriteString(fmt.Sprintf("    if val, err :=New%sMessageBy%s(p.%s); err != nil {\n", strcase.ToCamel(p.Name), matchKeyCamel, matchKeyCamel))
		b.WriteString("        return err\n")
		b.WriteString("    } else {\n")
		b.WriteString(fmt.Sprintf("        p.%s = val\n", fieldNameCamel))
		b.WriteString("    }\n")
		b.WriteString("}\n")
		b.WriteString(fmt.Sprintf("    if err := p.%s.Encode(buf); err != nil {\n", fieldNameCamel))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	} else {
		b.WriteString("--" + field.GetType() + ":" + field.Name + " is not supported for encoding--\n")
	}
	return b.String()
}

func (g GoGenerator) generateEncodingListField(field *model.Field) string {
	var b strings.Builder
	listLenType := goBasicTypeMap[g.config.ListLenPrefixLenType]
	order := g.getOrder()
	fieldNameCamel := strcase.ToCamel(field.Name)
	if _, ok := goBasicTypeMap[field.GetType()]; ok {
		b.WriteString(fmt.Sprintf("    if err := codec.PutBasicTypeList%s[%s](buf, p.%s); err != nil {\n", order, listLenType.BasicType, fieldNameCamel))
		b.WriteString("        return fmt.Errorf(\"failed to encode %s: %w\", \"" + field.Name + "\", err)\n")
		b.WriteString("    }\n")
	} else if l, ok := ParseCharArrayType(field.GetType()); ok {
		// fixed string
		b.WriteString(fmt.Sprintf("    if err := codec.PutFixedStringList%s[%s](buf, p.%s, %s); err != nil {\n", order, listLenType.BasicType, fieldNameCamel, l))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	} else if field.InerObject != nil {
		b.WriteString(fmt.Sprintf("    if err := codec.PutObjectList%s[%s](buf, p.%s, %s); err != nil {\n", order, listLenType.BasicType, fieldNameCamel, l))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	} else if _, ok := g.binModel.PacketsMap[field.GetType()]; ok {
		b.WriteString(fmt.Sprintf("    if err := codec.PutObjectList%s[%s](buf, p.%s, %s); err != nil {\n", order, listLenType.BasicType, fieldNameCamel, l))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	} else if field.GetType() == "string" || field.GetType() == "char[]" {
		//dynamic string
		strLenType := goBasicTypeMap[g.config.StringLenPrefixLenType]
		b.WriteString(fmt.Sprintf("    if err := codec.PutStringList%s[%s,%s](buf, p.%s); err != nil {\n", order, listLenType.BasicType, strLenType.BasicType, fieldNameCamel))
		b.WriteString("        return err\n")
		b.WriteString("    }\n")
	} else {
		b.WriteString("--" + field.GetType() + ":" + field.Name + " is not supported for encoding--\n")
	}
	return b.String()
}

func (g GoGenerator) generateGoTestFileForPacket(p *model.Packet, isIner bool) string {
	var b strings.Builder
	if !isIner {
		b.WriteString("// Code generated by fin-protoc. DO NOT EDIT.\n")
		b.WriteString(fmt.Sprintf("package %s_test", g.config.GoPackage))
		b.WriteString("\n\n")
		b.WriteString(`import (
		"bytes"
		"testing"

		"github.com/stretchr/testify/assert"
		`)
		b.WriteString(fmt.Sprintf("msg \"%s\"", g.config.GoModule))
		b.WriteString(")")
		b.WriteString("\n\n")
	}

	packageNameCamel := strcase.ToCamel(p.Name)
	b.WriteString(fmt.Sprintf("func Test%sCodec(t *testing.T) {\n", packageNameCamel))
	//new instance
	b.WriteString("\n")
	b.WriteString(g.generateNewInstance("original", p))

	//encode
	b.WriteString("    var buf bytes.Buffer\n")
	b.WriteString("    assert.NoError(t, original.Encode(&buf))\n")
	b.WriteString(fmt.Sprintf("    var decoded msg.%s\n", packageNameCamel))
	//decode
	b.WriteString("    assert.NoError(t, decoded.Decode(&buf))\n")
	//assert
	b.WriteString("    assert.Equal(t, original, &decoded)\n")

	b.WriteString("}\n")

	return b.String()
}

func (g GoGenerator) generateNewInstance(name string, p *model.Packet) string {
	var b strings.Builder
	for _, f := range p.Fields {
		fieldNameLowerCamel := strcase.ToLowerCamel(f.Name)
		if f.InerObject != nil {
			b.WriteString(g.generateNewInstance(fieldNameLowerCamel, f.InerObject))
		} else if fp, ok := g.binModel.PacketsMap[f.GetType()]; ok {
			b.WriteString(g.generateNewInstance(fieldNameLowerCamel, &fp))
		} else if f.GetType() == "match" {
			mp := f.MatchPairs[0]
			valuePackage := g.binModel.PacketsMap[mp.Value]
			b.WriteString(g.generateNewInstance(fieldNameLowerCamel, &valuePackage))
		}
	}
	b.WriteString(fmt.Sprintf("    %s := &msg.%s{\n", name, strcase.ToCamel(p.Name)))
	for _, f := range p.Fields {
		if p.MatchFields[f.MatchKey] != nil {
			if len(f.MatchPairs) > 0 {
				key := f.MatchPairs[0].Key
				b.WriteString(AddIndent4ln(AddIndent4(AddIndent4(fmt.Sprintf("%s: %s,", strcase.ToCamel(f.MatchKey), key)))))
				b.WriteString(AddIndent4ln(AddIndent4(AddIndent4(fmt.Sprintf("%s: %s,", strcase.ToCamel(f.Name), g.generateTestValue(&f))))))
			}
			continue
		}
		if p.MatchFields[f.Name] != nil {
			continue
		}
		b.WriteString(fmt.Sprintf("    %s : %s,\n", strcase.ToCamel(f.Name), g.generateTestValue(&f)))
	}
	b.WriteString("}\n")
	return b.String()
}

func (g GoGenerator) generateTestValue(f *model.Field) any {
	var testValue string
	ty := f.GetType()
	fieldNameLowerCamel := strcase.ToLowerCamel(f.Name)
	if typ, ok := goBasicTypeMap[f.GetType()]; ok {
		testValue = typ.TestValue
		ty = typ.BasicType
	} else if l, ok := ParseCharArrayType(f.GetType()); ok {
		num, _ := strconv.Atoi(l)
		testValue = "\"" + strings.Repeat("x", num) + "\""
		ty = "string"
	} else if f.GetType() == "match" {
		testValue = fieldNameLowerCamel
	} else if f.InerObject != nil {
		testValue = fieldNameLowerCamel
	} else if _, ok := g.binModel.PacketsMap[f.GetType()]; ok {
		testValue = fieldNameLowerCamel
	} else if f.GetType() == "string" || f.GetType() == "char[]" {
		testValue = "\"hello\""
		ty = "string"
	} else {
		testValue = "-- unsupport " + f.GetType()
	}
	if f.IsRepeat {
		if f.InerObject != nil {
			return fmt.Sprintf("[]*msg.%s{%s}", ty, testValue)
		} else if _, ok := g.binModel.PacketsMap[f.GetType()]; ok {
			return fmt.Sprintf("[]*msg.%s{%s}", ty, testValue)
		}
		return fmt.Sprintf("[]%s{%s}", ty, testValue)
	}
	return testValue
}
